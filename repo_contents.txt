Repository: https://github.com/ompatel585/Cerlia_Playground
Total Files: 58
================================================================================


================================================================================
FILE: README.md
================================================================================

This is a Backend as a Service Project , started as a fun project . It , if gets completed , will provide fully functional backend to the frontend learners to make full stack projects .
Just define your schema , and api nodes like filling a form and you are done with your backend.
Happy Coding!!

================================================================================
FILE: api\index.js
================================================================================

// api/index.js
import serverless from "serverless-http";
import app from "../server/server.js";
import connectDB from "../server/config/db.js";

let handler;

export default async function (req, res) {
  if (!handler) {
    await connectDB();       // connect DB only once
    handler = serverless(app);
  }
  return handler(req, res);
}

================================================================================
FILE: api\package.json
================================================================================

{
  "name": "cerlia-api",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "build": "echo 'Serverless function - no build needed'"
  },
  "dependencies": {
    "serverless-http": "^4.0.0",
    "body-parser": "^2.2.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "express-session": "^1.18.2",
    "mongoose": "^8.17.0",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "qrcode": "^1.5.4"
  }
}

================================================================================
FILE: client\README.md
================================================================================

# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.

================================================================================
FILE: client\eslint.config.js
================================================================================

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

================================================================================
FILE: client\index.html
================================================================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================================================================================
FILE: client\package.json
================================================================================

{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "-": "^0.0.1",
    "@tailwindcss/vite": "^4.1.11",
    "@xyflow/react": "^12.8.2",
    "axios": "^1.11.0",
    "jsonwebtoken": "^9.0.2",
    "jwt-decode": "^4.0.0",
    "lucide-react": "^0.533.0",
    "qrcode": "^1.5.4",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-router-dom": "^7.7.0",
    "scrollbar": "^0.1.12",
    "tailwind": "^4.0.0",
    "tailwindcss": "^4.1.11"
  },
  "devDependencies": {
    "@eslint/js": "^9.30.1",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@vitejs/plugin-react": "^4.6.0",
    "eslint": "^9.30.1",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "tailwind-scrollbar": "^4.0.2",
    "vite": "^7.0.4"
  }
}

================================================================================
FILE: client\src\App.css
================================================================================

@import 'tailwindcss';

================================================================================
FILE: client\src\App.jsx
================================================================================

// App.jsx
import React from "react";
import {
  BrowserRouter as Router,
  Routes,
  Route,
  Navigate,
} from "react-router-dom";
// import FlowBuilder from "./components/FlowBuilder/FlowBuilder";
import Login from "./pages/auth/Login.jsx";
import { useAuth, AuthProvider } from "./state/hooks/useAuth.jsx";
import RestTriggers from "./pages/Flow Builder/index.jsx";
import FlowBuilder from "./components/FlowBuilder/FlowBuilder.jsx";

const ProtectedRoute = ({ children }) => {
  const { isAuthenticated, loading } = useAuth();

  if (loading) return <div className="text-white p-6">Loading...</div>;

  return isAuthenticated ? children : <Navigate to="/login" />;
};

const App = () => {
  return (
    // <div className="bg-[#030116] min-h-screen">
          <div className="bg-[#010411] min-h-screen">

      <AuthProvider>
        <Router>
          <Routes>
            <Route path="/login" element={<Login />} />
              <Route
              path="/"
              element={
               <ProtectedRoute> 
                  <RestTriggers />
                   <FlowBuilder /> 
                 </ProtectedRoute>
              }
            />
         
            
          </Routes>
        </Router>
      </AuthProvider>
    </div>
  );
};

export default App;

================================================================================
FILE: client\src\components\FlowBuilder\FlowBuilder.jsx
================================================================================

// import React, { useEffect ,useState } from "react";
// import { ReactFlow, MiniMap, ReactFlowProvider } from "@xyflow/react";
// import "@xyflow/react/dist/style.css";
// import { useFlowLogic } from "./useFlowLogic.jsx";
// import Connect from "../../features/connect/pages/Connect.jsx";
// import { X } from "lucide-react";
// import { useAuth } from "../../state/hooks/useAuth.jsx";
// import Navbar from "../Navbar/Navbar"; // âœ… NEW
// import SchemaNode from "../InputSchema/SchemaNode.jsx"; // correct relative path
// import SchemaPopup from "../InputSchema/SchemaPopup.jsx";
// import ServicePopup from "../../features/serviceNodes/components/ServicePopup.jsx";

// const nodeTypes = {
//   schemaNode: SchemaNode,
// };

// const FlowBuilder = () => {
//   const {
//     nodes: rawNodes,
//     edges,
//     onNodesChange,
//     onEdgesChange,
//     onConnect,
//     handleNodeClick,
//     showConnect,
//     setShowConnect,
//   } = useFlowLogic();

//   const { user } = useAuth(); // assumes user object like { name: "Om Patel", email: ... }

//   // State to manage SchemaPopup visibility and data
//   const [popup, setPopup] = useState({
//     isOpen: false,
//     nodeId: null,
//     onSave: null,
//   });
//   const [showServicePopup, setShowServicePopup] = useState(false);

//   // Handler to open popup
//   const openPopup = (nodeId, onSave) => {
//     setPopup({ isOpen: true, nodeId, onSave });
//   };

//   // Handler to close popup
//   const closePopup = () => {
//     setPopup({ isOpen: false, nodeId: null, onSave: null });
//   };

//   // Map over rawNodes to include openPopup in each node's data
//   const nodes = rawNodes.map((node) => ({
//     ...node,
//     data: {
//       ...node.data,
//       openPopup,
//     },
//   }));
//   useEffect(() => {
//     document.body.style.overflow =
//       showConnect || popup.isOpen ? "hidden" : "auto";
//     return () => {
//       document.body.style.overflow = "auto";
//     };
//   }, [showConnect, popup.isOpen]);

//   // useEffect(() => {
//   //   document.body.style.overflow = showConnect ? "hidden" : "auto";
//   //   return () => {
//   //     document.body.style.overflow = "auto";
//   //   };
//   // }, [showConnect]);

//   useEffect(() => {
//     const handler = () => setShowServicePopup(true);
//     window.addEventListener("openServicePopup", handler);
//     return () => window.removeEventListener("openServicePopup", handler);
//   }, []);

//   return (
//     <ReactFlowProvider>
//       <div className="flex w-screen h-screen overflow-hidden">
//         {/* Sidebar */}
//         {user && <Navbar />}

//         {/* Main Flow Area */}
//         <div className="relative flex-1">
//           <ReactFlow
//             nodes={nodes}
//             edges={edges}
//             onNodesChange={onNodesChange}
//             onEdgesChange={onEdgesChange}
//             onConnect={onConnect}
//             onNodeClick={handleNodeClick}
//             fitView
//             nodeInteractionWidth={40}
//             nodesDraggable={false}
//             nodesConnectable={false}
//             elementsSelectable={false}
//             nodeTypes={nodeTypes}
//           />
//           <MiniMap
//             nodeStrokeColor={(n) => {
//               if (n.style?.background) return n.style.background;
//               if (n.type === "input") return "#0ea5e9";
//               if (n.type === "output") return "#10b981";
//               return "#6366f1";
//             }}
//             nodeColor={() => "#a5b4fc"}
//             nodeStrokeWidth={3}
//             className="rounded-xl"
//           />

//           {/* Modal */}
//           {showConnect && (
//             <div className="fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center">
//               <div className="bg-gray-900 text-white rounded-lg p-6 w-[55%] max-w-5xl shadow-lg relative">
//                 <Connect />
//                 <button
//                   onClick={() => setShowConnect(false)}
//                   className="absolute top-7 right-4 text-white text-2xl cursor-pointer transition-all duration-200 ease-in-out hover:shadow-[0_0_10px_rgba(255,255,255,0.7)] hover:scale-105"
//                 >
//                   <X />
//                 </button>
//               </div>
//             </div>
//           )}

//           {/* Schema Popup */}
//           {popup.isOpen && (
//             <SchemaPopup onClose={closePopup} onSave={popup.onSave} />
//           )}

//           {showServicePopup && (
//             <ServicePopup
//               onClose={() => setShowServicePopup(false)}
//               onSelect={(serviceId) => {
//                 console.log("Selected service:", serviceId);
//                 // you can later add the logic to create node here
//               }}
//             />
//           )}
//         </div>
//       </div>
//     </ReactFlowProvider>
//   );
// };

// export default FlowBuilder;





// client/src/components/FlowBuilder/FlowBuilder.jsx
import React, { useEffect, useState } from "react";
import { ReactFlow, MiniMap, ReactFlowProvider } from "@xyflow/react";
import "@xyflow/react/dist/style.css";
import { useFlowLogic } from "./UseFlowLogic.jsx";
import Connect from "../../features/connect/pages/Connect.jsx";
import { X } from "lucide-react";
import { useAuth } from "../../state/hooks/useAuth.jsx";
import Navbar from "../Navbar/Navbar"; // âœ… NEW
import SchemaNode from "../InputSchema/SchemaNode.jsx"; // correct relative path
import SchemaPopup from "../InputSchema/SchemaPopup.jsx";
import ServicePopup from "../../features/serviceNodes/components/ServicePopup.jsx";
import QRCodeNode from "../../features/serviceNodes/services/qrCode/QRCodeNode.jsx";
import OutputNode from "../../features/OutputNode/OutputNode.jsx";

const nodeTypes = {
  // schemaNode: SchemaNode,
  // connectNode: Connect, // Your Connect
  schemaNode: SchemaNode,
  qrNode: QRCodeNode,
  outputNode: OutputNode, // New
};

const FlowBuilder = () => {
  const {
    nodes: rawNodes,
    edges,
    onNodesChange,
    onEdgesChange,
    onConnect,
    handleNodeClick,
    showConnect,
    setShowConnect,
    addServiceNode,
    setAddTargetId,
  } = useFlowLogic();

  const { user } = useAuth(); // assumes user object like { name: "Om Patel", email: ... }

  // State to manage SchemaPopup visibility and data
  const [popup, setPopup] = useState({
    isOpen: false,
    nodeId: null,
    onSave: null,
  });
  const [showServicePopup, setShowServicePopup] = useState(false);

  

  // Handler to open popup
  const openPopup = (nodeId, onSave) => {
    setPopup({ isOpen: true, nodeId, onSave });
  };

  // Handler to close popup
  const closePopup = () => {
    setPopup({ isOpen: false, nodeId: null, onSave: null });
  };

  // Map over rawNodes to include openPopup in each node's data
  const nodes = rawNodes.map((node) => ({
    ...node,
    data: {
      ...node.data,
      openPopup,
    },
  }));
  useEffect(() => {
    document.body.style.overflow =
      showConnect || popup.isOpen ? "hidden" : "auto";
    return () => {
      document.body.style.overflow = "auto";
    };
  }, [showConnect, popup.isOpen]);

  useEffect(() => {
    const handler = () => setShowServicePopup(true);
    window.addEventListener("openServicePopup", handler);
    return () => window.removeEventListener("openServicePopup", handler);
  }, []);

  return (
    <ReactFlowProvider>
      <div className="flex w-screen h-screen overflow-hidden">
        {/* Sidebar */}
        {user && <Navbar />}

        {/* Main Flow Area */}
        <div className="relative flex-1">
          <ReactFlow
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onNodeClick={handleNodeClick}
            fitView
            // nodeInteractionWidth={40}
            nodesDraggable={true}
            
            nodesConnectable={false}
            elementsSelectable={false}
            nodeTypes={nodeTypes}
          />
          <MiniMap
            nodeStrokeColor={(n) => {
              if (n.style?.background) return n.style.background;
              if (n.type === "input") return "#0ea5e9";
              if (n.type === "output") return "#10b981";
              return "#6366f1";
            }}
            nodeColor={() => "#a5b4fc"}
            nodeStrokeWidth={3}
            className="rounded-xl"
          />

          {/* Modal */}
          {showConnect && (
            <div className="fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center">
              <div className="bg-gray-900 text-white rounded-lg p-6 w-[55%] max-w-5xl shadow-lg relative">
                <Connect />
                <button
                  onClick={() => setShowConnect(false)}
                  className="absolute top-7 right-4 text-white text-2xl cursor-pointer transition-all duration-200 ease-in-out hover:shadow-[0_0_10px_rgba(255,255,255,0.7)] hover:scale-105"
                >
                  <X />
                </button>
              </div>
            </div>
          )}

          {/* Schema Popup */}
          {popup.isOpen && (
            <SchemaPopup onClose={closePopup} onSave={popup.onSave} />
          )}

          {/* {showServicePopup && (
            <ServicePopup
              onClose={() => setShowServicePopup(false)}
              onSelect={(serviceId, config) => {
                addServiceNode(addTargetId, serviceId, config);
                setShowServicePopup(false);
              }}
            />
          )} */}

          {showServicePopup && (
            <ServicePopup
              onClose={() => setShowServicePopup(false)}
              onSelect={(serviceId) => {
                addServiceNode( serviceId); // â† create new node
                setShowServicePopup(false);
              }}
            />
          )}
        </div>
      </div>
    </ReactFlowProvider>
  );
};

export default FlowBuilder;

================================================================================
FILE: client\src\components\FlowBuilder\NodeConfig.jsx
================================================================================

// // client/src/components/FlowBuilder/NodeConfig.jsx
// import { MarkerType, Position } from "@xyflow/react";
// import QRCodeNode from "../../features/serviceNodes/services/qrCode/QRCodeNode";
// import SchemaNode from "../InputSchema/SchemaNode";

// export let serviceCounter = 1;

// export const createNode = (id, x, y, label, type = null, opts = {}) => ({
//   id,
//   type,
//   position: { x, y },
//   data: { label },
//   sourcePosition: opts.sourcePosition ?? Position.Bottom,
//   targetPosition: opts.targetPosition ?? Position.Top,
//   style: {
//     padding: 10,
//     borderRadius: 8,
//     border: "1px solid #ccc",
//     backgroundColor: "#f0f0f0",
//     cursor: "pointer",
//   },
// });

// export const initialNodes = [
//   createNode("n1", 0, 0, "API Endpoint"),
//   createNode("n2", -50, 100, "Schema", "schemaNode", {
//     targetPosition: Position.Top,
//     sourcePosition: Position.Bottom,
//   }),
//   createNode("add-service", 0, 200, "+ Add a new Service Node"),
//   createNode("n4", 0, 550, "Output Node"), // â† INCREASED from 400 to 550
// ];

// export const initialEdges = [
//   {
//     id: "n1-n2",
//     source: "n1",
//     target: "n2",
//     type: "straight",
//     markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
//     style: { stroke: "#FC0AEC" },
//   },
//   {
//     id: "n2-add-service",
//     source: "n2",
//     target: "add-service",
//     type: "straight",
//     markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
//     style: { stroke: "#FC0AEC" },
//   },
//   {
//     id: "add-service-n4",
//     source: "add-service",
//     target: "n4",
//     type: "straight",
//     markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
//     style: { stroke: "#FC0AEC" },
//   },
// ];

// export const nodeTypes = {
//   schemaNode: SchemaNode,
//   qrNode: QRCodeNode,
// };



// // client/src/components/FlowBuilder/NodeConfig.jsx
// import { MarkerType, Position } from "@xyflow/react";
// import QRCodeNode from "../../features/serviceNodes/services/qrCode/QRCodeNode";
// import SchemaNode from "../InputSchema/SchemaNode";  // Your existing
// import Connect from "../../features/connect/pages/Connect";  // Your existing Connect as endpoint node
// import OutputNode from "../../features/OutputNode/OutputNode";  // New (see below)

// export let serviceCounter = 1;

// export const createNode = (id, x, y, label, type = null, opts = {}) => ({
//   id,
//   type,
//   position: { x, y },
//   data: { label, ...opts.data },
//   sourcePosition: opts.sourcePosition ?? Position.Bottom,
//   targetPosition: opts.targetPosition ?? Position.Top,
//   style: {
//     padding: 10,
//     borderRadius: 8,
//     border: "1px solid #ccc",
//     backgroundColor: "#f0f0f0",
//     cursor: "pointer",
//     minHeight: 'auto',  // Dynamic height
//     height: 'auto',     // Allow resizing
//   },
// });

// export const initialNodes = [
//   // Connect as first node (your REST API endpoint definer)
//   createNode("connect", 0, 0, "REST API", "connectNode", {
//     data: { endpoint: "/qr", methods: ["POST"] },  // Default /qr
//     minHeight: 400,  // Your Connect is tall
//   }),
//   // Your Schema node
//   createNode("schema", 0, 200, "Input Schema", "schemaNode", {
//     data: { 
//       inputs: [{ name: "url", type: "string", required: true }],  // Default URL input
//       openPopup: (nodeId, onSave) => { /* Your popup logic */ }
//     },
//     minHeight: 120,
//   }),
//   // Add Service placeholder
//   createNode("add-service", 0, 400, "+ Add Service Node"),
//   // New Output node
//   createNode("output", 0, 600, "Flow Output", "outputNode", {
//     data: { outputType: "qrCode", format: "json" },
//     minHeight: 150,
//   }),
// ];

// export const initialEdges = [
//   // Straight connections - no curves
//   {
//     id: "connect-schema",
//     source: "connect",
//     target: "schema",
//     type: "smoothstep",  // Straight but smooth if needed; use "default" for pure straight
//     markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
//     style: { stroke: "#FC0AEC", strokeWidth: 2 },
//   },
//   {
//     id: "schema-add-service",
//     source: "schema",
//     target: "add-service",
//     type: "smoothstep",
//     markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
//     style: { stroke: "#FC0AEC", strokeWidth: 2 },
//   },
//   {
//     id: "add-service-output",
//     source: "add-service",
//     target: "output",
//     type: "smoothstep",
//     markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
//     style: { stroke: "#FC0AEC", strokeWidth: 2 },
//   },
// ];

// export const nodeTypes = {
//   connectNode: Connect,  // Your existing Connect component
//   schemaNode: SchemaNode,  // Your existing
//   qrNode: QRCodeNode,  // Your existing, but generic for services
//   outputNode: OutputNode,  // New
// };




// client/src/components/FlowBuilder/NodeConfig.jsx

// import { MarkerType, Position } from "@xyflow/react";
// import QRCodeNode from "../../features/serviceNodes/services/qrCode/QRCodeNode";
// import SchemaNode from "../InputSchema/SchemaNode";  // Your existing
// import Connect from "../../features/connect/pages/Connect";  // Your existing Connect as endpoint node
// import OutputNode from "../../features/OutputNode/OutputNode";  // New (see below)

import { MarkerType, Position } from "@xyflow/react";
import QRCodeNode from "../../features/serviceNodes/services/qrCode/QRCodeNode";
import SchemaNode from "../InputSchema/SchemaNode";
import OutputNode from "../../features/OutputNode/OutputNode";

export let serviceCounter = 1;

export const createNode = (id, x, y, label, type = null, opts = {}) => ({
  id,
  type,
  position: { x, y },
  data: { label, ...opts.data },
  sourcePosition: opts.sourcePosition ?? Position.Bottom,
  targetPosition: opts.targetPosition ?? Position.Top,
  style: {
    padding: 10,
    borderRadius: 8,
    border: "1px solid #ccc",
    backgroundColor: "#f0f0f0",
    cursor: "pointer",
  },
});

// Simple Endpoint Display Node (not your Connect modal)
const EndpointNode = ({ data }) => {
  const endpoint = data?.endpoint || "/";
  const method = data?.method || "POST";
  const baseUrl = data?.baseUrl || "";
  
  return (
    <div className="bg-blue-50 border-2 border-blue-400 rounded-lg p-4 w-[260px]">
      <Handle type="source" position={Position.Bottom} className="!bg-blue-500" />
      <div className="flex items-center gap-2 mb-2">
        <div className="w-2 h-2 bg-blue-500 rounded-full"></div>
        <span className="text-sm font-bold text-blue-800">REST API Call</span>
      </div>
      <div className="text-xs space-y-1">
        <div className="font-mono bg-white p-2 rounded border">
          <span className="text-blue-600">{method}</span>
        </div>
        <div className="font-mono bg-white p-2 rounded border text-[11px]">
          {baseUrl}{endpoint}
        </div>
      </div>
    </div>
  );
};

export const initialNodes = [
  createNode("endpoint", 0, 0, "REST API", "endpointNode", {
    data: { endpoint: "/", method: "POST", baseUrl: "" },
  }),
  createNode("schema", 0, 140, "Input Schema", "schemaNode", {
    data: { inputs: [] },
  }),
  createNode("add-service", 0, 300, "+ Add Service Node"),
  createNode("output", 0, 500, "Flow Output", "outputNode", {
    data: {},
  }),
];

export const initialEdges = [
  {
    id: "endpoint-schema",
    source: "endpoint",
    target: "schema",
    type: "straight",
    markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
    style: { stroke: "#FC0AEC", strokeWidth: 2 },
  },
  {
    id: "schema-add-service",
    source: "schema",
    target: "add-service",
    type: "straight",
    markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
    style: { stroke: "#FC0AEC", strokeWidth: 2 },
  },
  {
    id: "add-service-output",
    source: "add-service",
    target: "output",
    type: "straight",
    markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
    style: { stroke: "#FC0AEC", strokeWidth: 2 },
  },
];

export const nodeTypes = {
  endpointNode: EndpointNode,
  schemaNode: SchemaNode,
  qrNode: QRCodeNode,
  outputNode: OutputNode,
};

================================================================================
FILE: client\src\components\FlowBuilder\UseFlowLogic.jsx
================================================================================

// //client/src/components/FlowBuilder/UseFlowLogic.jsx
// import { useState, useCallback, useEffect } from "react";
// import {
//   applyNodeChanges,
//   applyEdgeChanges,
//   MarkerType,
//   Position,
// } from "@xyflow/react"; // âœ… Added Position
// import {
//   initialNodes,
//   initialEdges,
//   createNode,
//   serviceCounter as baseServiceCounter,
// } from "./NodeConfig.jsx";

// let serviceCounter = baseServiceCounter;

// export const useFlowLogic = () => {
//   const [nodes, setNodes] = useState(initialNodes);
//   const [edges, setEdges] = useState(initialEdges);
//   const [showConnect, setShowConnect] = useState(false);

//   const onNodesChange = useCallback(
//     (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
//     []
//   );
//   const onEdgesChange = useCallback(
//     (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),
//     []
//   );

//   const handleNodeClick = (event, node) => {
//     if (node.id === "add-service") {
//       // ðŸŸ¢ trigger popup instead of auto-adding node
//       const openEvent = new CustomEvent("openServicePopup");
//       window.dispatchEvent(openEvent);
//     } else if (node.id.startsWith("service-")) {
//       addServiceNode(node.id);
//     } else if (node.id === "n1") {
//       setShowConnect(true);
//     }
//   };

 
// const addServiceNode = (serviceId) => {
//   const sourceId = "add-service";
//   const newServiceId = `service-${serviceCounter++}`;

//   const serviceConfig = {
//     "qr-generator": {
//       type: "qrNode",
//       label: "QR Code Generator",
//     },
//   };

//   const config = serviceConfig[serviceId];
//   if (!config) {
//     console.error("Unknown service:", serviceId);
//     return;
//   }

//   const clickedNode = nodes.find((n) => n.id === sourceId);
//   if (!clickedNode) {
//     console.error("Source node not found:", sourceId);
//     return;
//   }

//   const nodesBelow = nodes
//     .filter((n) => n.position.y > clickedNode.position.y)
//     .sort((a, b) => a.position.y - b.position.y);
//   const nextNode = nodesBelow[0] ?? nodes.find((n) => n.id === "n4");

//   if (!nextNode) {
//     console.error("Next node not found");
//     return;
//   }

//   // ðŸ”¥ INCREASED spacing to prevent overlap
//   const spacing = 250; // â† was 150, now 250
//   const newY = clickedNode.position.y + spacing;

//   const newNode = {
//     id: newServiceId,
//     type: config.type,
//     position: { x: clickedNode.position.x, y: newY },
//     data: { label: config.label },
//     sourcePosition: Position.Bottom,
//     targetPosition: Position.Top,
//   };

//   setNodes((nds) => {
//     const shifted = nds.map((n) =>
//       n.position.y >= newY
//         ? { ...n, position: { ...n.position, y: n.position.y + spacing } }
//         : n
//     );

//     return [...shifted, newNode].sort((a, b) => a.position.y - b.position.y);
//   });

//   setEdges((eds) => {
//     const updated = eds.map((e) =>
//       e.source === sourceId && e.target === nextNode.id
//         ? { ...e, target: newServiceId }
//         : e
//     );

//     updated.push({
//       id: `${newServiceId}-${nextNode.id}`,
//       source: newServiceId,
//       target: nextNode.id,
//       type: "straight", // â† explicit straight type
//       markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
//       style: { stroke: "#FC0AEC" },
//     });

//     return updated;
//   });
// };

//   useEffect(() => {
//     const handler = (e) => {
//       const { nodeId, diff } = e.detail;
//       if (Math.abs(diff) < 1) return;

//       setNodes((nds) =>
//         nds.map((n) => {
//           const schemaNode = nds.find((nn) => nn.id === nodeId);
//           if (!schemaNode || n.id === nodeId) return n;
//           return n.position.y > schemaNode.position.y
//             ? { ...n, position: { ...n.position, y: n.position.y + diff } }
//             : n;
//         })
//       );
//     };

//     window.addEventListener("nodeHeightChange", handler);
//     return () => window.removeEventListener("nodeHeightChange", handler);
//   }, []);

//   return {
//     nodes,
//     edges,
//     onNodesChange,
//     onEdgesChange,
//     handleNodeClick,
//     showConnect,
//     setShowConnect,
//     addServiceNode, // âœ… make sure this is returned
//   };
// };













// // client/src/components/FlowBuilder/UseFlowLogic.jsx
// import { useState, useCallback, useEffect } from "react";
// import {
//   applyNodeChanges,
//   applyEdgeChanges,
//   MarkerType,
//   Position,
// } from "@xyflow/react";
// import {
//   initialNodes,
//   initialEdges,
//   createNode,
//   serviceCounter as baseServiceCounter,
// } from "./NodeConfig.jsx";  // Your updated config

// let serviceCounter = baseServiceCounter;

// export const useFlowLogic = () => {
//   const [nodes, setNodes] = useState(initialNodes);
//   const [edges, setEdges] = useState(initialEdges);
//   const [showConnect, setShowConnect] = useState(false);  // For your Connect modal

//   const onNodesChange = useCallback(
//     (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
//     []
//   );

//   const onEdgesChange = useCallback(
//     (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),
//     []
//   );

//   const onConnect = useCallback((connection) => {
//     setEdges((eds) => {
//       const newEdge = { ...connection, type: "smoothstep", style: { stroke: "#FC0AEC", strokeWidth: 2 } };
//       return applyEdgeChanges([{ type: "add", item: newEdge }], eds);
//     });
//   }, []);

//   const handleNodeClick = (event, node) => {
//     if (node.id === "add-service") {
//       // Open your ServicePopup
//       const openEvent = new CustomEvent("openServicePopup");
//       window.dispatchEvent(openEvent);
//     } else if (node.id === "connect") {
//       // Open your Connect modal if needed
//       setShowConnect(true);
//     } else if (node.id === "schema") {
//       // Open your SchemaPopup via data.openPopup
//       node.data.openPopup?.(node.id, (field) => {
//         // Handle schema save - update node data
//         setNodes((nds) => nds.map((n) => n.id === node.id ? { ...n, data: { ...n.data, inputs: [...n.data.inputs, field] } } : n));
//       });
//     }
//   };

//   // Handle dynamic height changes from your SchemaNode ResizeObserver
//   useEffect(() => {
//     const handler = (e) => {
//       const { nodeId, diff } = e.detail;
//       if (Math.abs(diff) < 1) return;

//       setNodes((nds) =>
//         nds.map((n) => {
//           const schemaNode = nds.find((nn) => nn.id === nodeId);
//           if (!schemaNode || n.id === nodeId) return n;
//           if (n.position.y > schemaNode.position.y) {
//             return { ...n, position: { ...n.position, y: n.position.y + diff } };
//           }
//           return n;
//         })
//       );
//       // Shift downstream edges too
//       setEdges((eds) => eds.map((e) => {
//         if (e.target === nodeId || e.source === nodeId) {
//           // Reconnect straight
//           return { ...e, type: "smoothstep" };
//         }
//         return e;
//       }));
//     };

//     window.addEventListener("nodeHeightChange", handler);
//     return () => window.removeEventListener("nodeHeightChange", handler);
//   }, []);

//   const addServiceNode = (serviceId) => {
//     const sourceId = "add-service";
//     const outputId = "output";
//     const newServiceId = `service-${serviceCounter++}`;

//     // Generic service config - QR as example, easy to add 100s
//     const serviceConfig = {
//       "qr-generator": {
//         type: "qrNode",
//         label: "QR Code Service",
//         data: { scale: 4, format: "png" },  // Config for QR
//       },
//       // Future: "pdf-generator": { type: "pdfNode", label: "PDF Service" },
//     };

//     const config = serviceConfig[serviceId];
//     if (!config) {
//       console.error("Unknown service:", serviceId);
//       return;
//     }

//     const sourceNode = nodes.find((n) => n.id === sourceId);
//     const outputNode = nodes.find((n) => n.id === outputId);
//     if (!sourceNode || !outputNode) return;

//     // Dynamic positioning - 160px min spacing to avoid overlap
//     const serviceY = sourceNode.position.y + 160;
//     const newOutputY = serviceY + 180;  // Extra for service height

//     // Create generic service node (your QRCodeNode)
//     const newNode = createNode(newServiceId, sourceNode.position.x, serviceY, config.label, config.type, {
//       data: config.data,
//       minHeight: 140,  // QR node height
//     });

//     // Update nodes: Insert service, shift output down
//     setNodes((nds) => {
//       const updated = nds
//         .map((n) => {
//           if (n.id === outputId) {
//             return { ...n, position: { ...n.position, y: newOutputY } };
//           }
//           if (n.id === sourceId) {
//             return { ...n, data: { ...n.data, label: "âœ“ Service Added" } };  // Mark as done
//           }
//           return n;
//         })
//         .filter((n) => n.id !== sourceId)  // Remove add-service placeholder
//         .concat(newNode)
//         .sort((a, b) => a.position.y - b.position.y);  // Reorder

//       return updated;
//     });

//     // Update edges: Connect full flow - connect â†’ schema â†’ service â†’ output (straight)
//     setEdges((eds) => {
//       // Remove old add-service â†’ output
//       let updated = eds.filter((e) => !(e.source === sourceId && e.target === outputId));

//       // Ensure full chain: connect â†’ schema â†’ service â†’ output
//       updated = updated.filter((e) => e.id !== "schema-add-service");  // Clean old
//       updated.push(
//         // Existing connect â†’ schema (already there)
//         {
//           id: `${sourceId.replace("add", "service")}-${outputId}`,  // New service â†’ output
//           source: newServiceId,
//           target: outputId,
//           type: "smoothstep",  // Straight
//           markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
//           style: { stroke: "#FC0AEC", strokeWidth: 2 },
//           animated: true,  // Visual flow indication
//         },
//         // Schema â†’ service
//         {
//           id: "schema-service",
//           source: "schema",
//           target: newServiceId,
//           type: "smoothstep",
//           markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
//           style: { stroke: "#FC0AEC", strokeWidth: 2 },
//           animated: true,
//         }
//       );

//       return updated;
//     });
//   };

//   return {
//     nodes,
//     edges,
//     onNodesChange,
//     onEdgesChange,
//     onConnect,
//     handleNodeClick,
//     showConnect,
//     setShowConnect,
//     addServiceNode,
//   };
// };


// client/src/components/FlowBuilder/UseFlowLogic.jsx

// client/src/components/FlowBuilder/UseFlowLogic.jsx
import { useState, useCallback, useEffect } from "react";
import {
  applyNodeChanges,
  applyEdgeChanges,
  MarkerType,
  Position,
} from "@xyflow/react";
import {
  initialNodes,
  initialEdges,
  serviceCounter as baseServiceCounter,
} from "./NodeConfig.jsx";

let serviceCounter = baseServiceCounter;

export const useFlowLogic = () => {
  const [nodes, setNodes] = useState(initialNodes);
  const [edges, setEdges] = useState(initialEdges);
  const [showConnect, setShowConnect] = useState(false);
  const [flowData, setFlowData] = useState({
    endpoint: "/",
    method: "POST",
    schemaInputs: [],
    serviceConfig: {},
  });

  const onNodesChange = useCallback(
    (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
    []
  );

  const onEdgesChange = useCallback(
    (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),
    []
  );

  const onConnect = useCallback(() => {}, []);

  const handleNodeClick = (event, node) => {
    if (node.id === "add-service") {
      const openEvent = new CustomEvent("openServicePopup");
      window.dispatchEvent(openEvent);
    } else if (node.id === "endpoint") {
      setShowConnect(true);
    }
  };

  // Listen for Connect form submitting a route
  useEffect(() => {
    const handleRouteCreated = (e) => {
      const { path, methods } = e.detail;
      
      // Update endpoint node with dynamic path
      setNodes((nds) =>
        nds.map((n) =>
          n.id === "endpoint"
            ? {
                ...n,
                data: {
                  ...n.data,
                  endpoint: path,
                  method: methods[0], // Use first method
                  baseUrl: "", // Will be dynamic in prod
                },
              }
            : n
        )
      );

      // Update flow data for backend calls
      setFlowData((prev) => ({
        ...prev,
        endpoint: path,
        method: methods[0],
      }));

      setShowConnect(false);
    };

    window.addEventListener("routeCreated", handleRouteCreated);
    return () => window.removeEventListener("routeCreated", handleRouteCreated);
  }, []);

  // Listen for schema updates
  useEffect(() => {
    const handleSchemaUpdate = (e) => {
      const { inputs } = e.detail;
      setFlowData((prev) => ({ ...prev, schemaInputs: inputs }));
    };

    window.addEventListener("schemaUpdated", handleSchemaUpdate);
    return () => window.removeEventListener("schemaUpdated", handleSchemaUpdate);
  }, []);

  // Handle dynamic height changes
  useEffect(() => {
    const handler = (e) => {
      const { nodeId, diff } = e.detail;
      if (Math.abs(diff) < 1) return;

      setNodes((nds) =>
        nds.map((n) => {
          const changedNode = nds.find((nn) => nn.id === nodeId);
          if (!changedNode || n.id === nodeId) return n;
          if (n.position.y > changedNode.position.y) {
            return { ...n, position: { ...n.position, y: n.position.y + diff } };
          }
          return n;
        })
      );
    };

    window.addEventListener("nodeHeightChange", handler);
    return () => window.removeEventListener("nodeHeightChange", handler);
  }, []);

  const addServiceNode = (serviceId) => {
    const sourceId = "add-service";
    const outputId = "output";
    const newServiceId = `service-${serviceCounter++}`;

    // GENERIC service configs - add 100s here easily
    const serviceConfig = {
      "qr-generator": {
        type: "qrNode",
        label: "Generate QR Code",
        config: { scale: 4, format: "png" },
      },
      // Future: "pdf-generator", "email-sender", "image-resize", etc.
    };

    const config = serviceConfig[serviceId];
    if (!config) return;

    const sourceNode = nodes.find((n) => n.id === sourceId);
    const outputNode = nodes.find((n) => n.id === outputId);
    if (!sourceNode || !outputNode) return;

    const serviceY = sourceNode.position.y + 160;
    const newOutputY = serviceY + 200;

    const newNode = {
      id: newServiceId,
      type: config.type,
      position: { x: sourceNode.position.x, y: serviceY },
      data: {
        label: config.label,
        config: config.config,
        flowData, // Pass endpoint + schema data
      },
      sourcePosition: Position.Bottom,
      targetPosition: Position.Top,
    };

    setNodes((nds) => {
      const updated = nds
        .map((n) => {
          if (n.id === outputId) {
            return {
              ...n,
              position: { ...n.position, y: newOutputY },
              data: { ...n.data, flowData }, // Pass to output
            };
          }
          if (n.id === sourceId) {
            return { ...n, data: { ...n.data, label: "âœ“ Service Added" } };
          }
          return n;
        })
        .filter((n) => n.id !== sourceId);

      return [...updated, newNode].sort((a, b) => a.position.y - b.position.y);
    });

    setEdges((eds) => {
      let updated = eds.filter(
        (e) => !(e.source === sourceId && e.target === outputId)
      );
      updated = updated.filter((e) => e.id !== "schema-add-service");

      updated.push(
        {
          id: "schema-service",
          source: "schema",
          target: newServiceId,
          type: "straight",
          markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
          style: { stroke: "#FC0AEC", strokeWidth: 2 },
        },
        {
          id: "service-output",
          source: newServiceId,
          target: outputId,
          type: "straight",
          markerEnd: { type: MarkerType.ArrowClosed, color: "#FC0AEC" },
          style: { stroke: "#FC0AEC", strokeWidth: 2 },
        }
      );

      return updated;
    });

    // Update flow config with service
    setFlowData((prev) => ({
      ...prev,
      serviceConfig: config.config,
    }));
  };

  return {
    nodes,
    edges,
    onNodesChange,
    onEdgesChange,
    onConnect,
    handleNodeClick,
    showConnect,
    setShowConnect,
    addServiceNode,
    flowData, // Expose for backend calls
  };
};

================================================================================
FILE: client\src\components\InputSchema\SchemaNode.jsx
================================================================================


//client/src/components/InputSchema/SchemaNode.jsx
import React, { useState, useEffect, useRef } from "react";
import { Handle, Position } from "@xyflow/react";
import SchemaPopup from "./SchemaPopup";
import { Plus } from "lucide-react";

export default function SchemaNode({ id, data }) {
  // const [showPopup, setShowPopup] = useState(false);
  const [fields, setFields] = useState([]);
  const containerRef = useRef(null);
  const prevHeight = useRef(0);

  const handleSave = (field) => {
    setFields((prev) => [...prev, field]);
  };

  // detect height changes
  useEffect(() => {
    if (!containerRef.current) return;
    const resizeObserver = new ResizeObserver((entries) => {
      for (let entry of entries) {
        const newHeight = entry.contentRect.height;
        const diff = newHeight - prevHeight.current;
        if (Math.abs(diff) > 0.5) {
          window.dispatchEvent(
            new CustomEvent("nodeHeightChange", {
              detail: { nodeId: id, diff },
            })
          );
          prevHeight.current = newHeight;
        }
      }
    });
    resizeObserver.observe(containerRef.current);

    return () => resizeObserver.disconnect();
  }, [id]);

  return (
    <div
      ref={containerRef}
      className="relative flex flex-col gap-2 p-3 bg-gradient-to-b from-white to-gray-50 border border-gray-200 rounded-xl shadow-lg w-[228px]  hover:shadow-xl transition-all duration-200"
    >
      {/* Handles */}
      <Handle
        type="target"
        position={Position.Top}
        className="!bg-indigo-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        className="!bg-indigo-500"
      />

      {/* Title */}
      <h4 className="text-sm font-bold text-gray-800 tracking-wide border-b pb-1 border-gray-100">
        {data.label}
      </h4>

      {/* Fields */}
      <div className="flex flex-col gap-1 text-xs text-gray-700">
        {fields.length === 0 ? (
          <span className="text-gray-400 italic">No fields yet</span>
        ) : (
          fields.map((f, idx) => (
            <div
              key={idx}
              className="px-2 py-1 rounded-md bg-gray-100 hover:bg-gray-200 transition text-gray-700 flex justify-between items-center"
            >
              <span className="font-medium">{f.name}</span>
              <span className="text-gray-500">({f.type})</span>
            </div>
          ))
        )}
      </div>

      {/* Add button */}
      <button
        // onClick={() => setShowPopup(true)}
        onClick={() => data.openPopup(id, handleSave)}
        className="cursor-pointer flex items-center justify-center gap-1 mt-1 bg-indigo-500 text-white text-xs px-2 py-1.5 rounded-md hover:bg-indigo-600 transition-all"
      >
        <Plus size={14} /> Add
      </button>

      {/* Popup */}
      {/* {showPopup && (
        <SchemaPopup onClose={() => setShowPopup(false)} onSave={handleSave} />
      )} */}
    </div>
  );
}

================================================================================
FILE: client\src\components\InputSchema\SchemaPopup.jsx
================================================================================



//client/src/components/InputSchema/SchemaPopup.jsx
import React, { useState, useRef, useEffect } from "react";
import { X, ChevronDown, Check } from "lucide-react";

export default function SchemaPopup({ onClose, onSave }) {
  const [field, setField] = useState({
    name: "",
    type: "string",
    nullable: false,
    required: false,
    unique: false,
    min: "",
    max: "",
  });

  const [dropdownOpen, setDropdownOpen] = useState(false);
  const dropdownRef = useRef(null);

  const typeOptions = ["string", "number", "integer", "boolean"];

  // close dropdown on outside click
  useEffect(() => {
    const handleClickOutside = (e) => {
      if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
        setDropdownOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const handleSave = () => {
    if (!field.name.trim()) return;
    onSave(field);
    onClose();
  };

  return (
    <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50">
      <div className="relative w-[90%] max-w-md bg-gray-900 border border-white/10 rounded-2xl p-6 shadow-xl animate-scaleIn overflow-hidden">
        {/* Header */}
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold tracking-wide text-fuchsia-200">
            Add Schema Field
          </h2>
          <button
            onClick={onClose}
            className="p-2 rounded-full hover:bg-white/10 transition"
          >
            <X size={20} className="text-gray-300" />
          </button>
        </div>

        {/* Body */}
        <div className="flex flex-col gap-4">
          {/* Field Name */}
          <div className="flex flex-col gap-2">
            <label className="text-sm font-medium text-white">Field Name</label>
            <input
              type="text"
              name="name"
              value={field.name}
              onChange={(e) =>
                setField((prev) => ({ ...prev, name: e.target.value }))
              }
              placeholder="e.g. username"
              className="h-[45px] w-full bg-white/10 border border-white/20 text-white px-4 py-2 rounded-xl placeholder-white/50 backdrop-blur-sm 
                         focus:outline-none focus:border-fuchsia-400 focus:ring-2 focus:ring-fuchsia-500/50"
            />
          </div>

          {/* Type dropdown (custom) */}
          <div className="flex flex-col gap-2">
            <label className="text-sm font-medium text-white">Type</label>
            <div ref={dropdownRef} className="relative w-full">
              <button
                onClick={() => setDropdownOpen((prev) => !prev)}
                className="h-[45px] w-full bg-white/10 border border-white/20 text-white px-4 py-2 rounded-xl flex items-center justify-between text-sm font-medium"
              >
                <span className="capitalize">{field.type}</span>
                <ChevronDown className="w-4 h-4" />
              </button>
              {dropdownOpen && (
                <div className="absolute z-10 mt-2 w-full bg-gray-800 border border-gray-700 rounded-lg shadow-lg max-h-[200px] overflow-y-auto">
                  {typeOptions.map((type) => (
                    <div
                      key={type}
                      onClick={() => {
                        setField((prev) => ({ ...prev, type }));
                        setDropdownOpen(false);
                      }}
                      className={`flex items-center justify-between px-4 py-2 text-sm cursor-pointer rounded-md transition-all duration-200
                        ${
                          field.type === type
                            ? "border border-fuchsia-500/50 bg-gray-700 text-white"
                            : "text-gray-300 hover:bg-gray-700"
                        }`}
                    >
                      <span className="capitalize">{type}</span>
                      {field.type === type && (
                        <Check className="w-4 h-4 text-fuchsia-300" />
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>

          {/* Constraints */}
          <div className="flex flex-col gap-2">
            <p className="text-sm font-medium text-white">Constraints</p>
            <div className="flex flex-wrap gap-4">
              {["nullable", "required", "unique"].map((opt) => (
                <label
                  key={opt}
                  className="flex items-center gap-2 cursor-pointer text-gray-300 hover:text-fuchsia-300 transition"
                >
                  <input
                    type="checkbox"
                    name={opt}
                    checked={field[opt]}
                    onChange={(e) =>
                      setField((prev) => ({
                        ...prev,
                        [opt]: e.target.checked,
                      }))
                    }
                    className="h-4 w-4 rounded border-gray-400 text-fuchsia-500 focus:ring-fuchsia-400"
                  />
                  <span className="capitalize">{opt}</span>
                </label>
              ))}
            </div>
          </div>

          {/* Min / Max */}
          {(field.type === "integer" || field.type === "number") && (
            <div className="flex gap-4 w-full max-w-full">
              <input
                type="number"
                name="min"
                placeholder="Min"
                value={field.min}
                onChange={(e) =>
                  setField((prev) => ({ ...prev, min: e.target.value }))
                }
                className="flex-1 h-[45px] w-full max-w-full bg-white/10 border border-white/20 text-white px-4 py-2 rounded-xl 
                           placeholder-white/50 focus:outline-none focus:border-fuchsia-400 focus:ring-2 focus:ring-fuchsia-500/50"
              />
              <input
                type="number"
                name="max"
                placeholder="Max"
                value={field.max}
                onChange={(e) =>
                  setField((prev) => ({ ...prev, max: e.target.value }))
                }
                className="flex-1 h-[45px] w-full max-w-full bg-white/10 border border-white/20 text-white px-4 py-2 rounded-xl 
                           placeholder-white/50 focus:outline-none focus:border-fuchsia-400 focus:ring-2 focus:ring-fuchsia-500/50"
              />
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="mt-6 flex justify-end gap-3">
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm rounded-lg font-semibold border border-white/20 text-gray-300 
                       hover:bg-white/10 transition-all duration-200"
          >
            Cancel
          </button>
          <button
            onClick={handleSave}
            className="px-4 py-2 text-sm rounded-lg font-semibold 
                       bg-gradient-to-r from-violet-600 to-fuchsia-600 text-white
                       shadow-md hover:scale-105 hover:shadow-fuchsia-500/50 transition-all duration-200"
          >
            Save
          </button>
        </div>
      </div>
    </div>
  );
}


================================================================================
FILE: client\src\components\Navbar\Navbar.jsx
================================================================================

//client/src/components/Navbar/Navbar.jsx
import React from "react";
import { useAuth } from "../../state/hooks/useAuth";
import { LogOut } from "lucide-react";

const Navbar = () => {
  const { user } = useAuth();

  const handleLogout = () => {
    window.open("/api/auth/logout", "_self");
  };

  const initial = user?.name?.[0]?.toUpperCase() || "?";

  return (
    <div className="w-60 h-full bg-[#0e0e2c] text-white p-4 flex flex-col justify-between shadow-md">
      {/* Top Section */}
      <div>
        {/* Avatar and Name */}
        <div className="flex items-center gap-3 mb-8">
          <div className="w-7 h-7 flex items-center justify-center rounded-full bg-blue-600 text-white font-bold text-lg shadow">
            {initial}
          </div>
          <div className="text-sm font-semibold whitespace-nowrap">
            {user?.name}
          </div>
        </div>

        {/* Navigation Items (add more below) */}
        <div className="flex flex-col gap-4 text-sm text-gray-300">
          <button className="hover:text-white transition">
            ðŸ—ï¸ Flow Builder
          </button>
          {/* â¬‡ï¸ Add more nav buttons here */}
          {/* <button className="hover:text-white transition">ðŸ“Š Analytics</button> */}
        </div>
      </div>

      {/* Logout */}
      <button
        onClick={handleLogout}
        className=" cursor-pointer flex items-center gap-2 text-red-400 hover:text-red-500 text-sm"
      >
        <LogOut size={16} />
        Logout
      </button>
    </div>
  );
};

export default Navbar;

================================================================================
FILE: client\src\features\OutputNode\OutputNode.jsx
================================================================================

// // client/src/features/outputNode/OutputNode.jsx
// import React, { useState } from "react";
// import { Handle, Position } from "@xyflow/react";

// const OutputNode = ({ data = {} }) => {
//   const [format, setFormat] = useState(data.format || "json");

//   return (
//     <div className="relative flex flex-col gap-3 p-4 bg-gradient-to-b from-green-50 to-white border border-green-200 rounded-xl shadow-md w-[240px] min-h-[150px] hover:shadow-lg transition-all">
//       {/* Handles for connection */}
//       <Handle
//         type="target"
//         position={Position.Top}
//         className="!bg-green-500 w-4 h-4"
//       />
//       <Handle
//         type="source"
//         position={Position.Bottom}
//         className="!bg-green-500 w-4 h-4"
//         id="output-handle"
//       />

//       {/* Title - Buildship style */}
//       <div className="flex items-center gap-2">
//         <div className="w-2 h-2 bg-green-500 rounded-full"></div>
//         <h4 className="text-sm font-bold text-green-800 tracking-wide">
//           Flow Output
//         </h4>
//       </div>

//       {/* Config */}
//       <div className="space-y-2 text-xs">
//         <label className="block text-gray-700 font-medium">
//           Response Format
//         </label>
//         <select
//           value={format}
//           onChange={(e) => setFormat(e.target.value)}
//           className="w-full px-2 py-1 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500"
//         >
//           <option value="json">JSON (qrCode: base64)</option>
//           <option value="image">Direct PNG</option>
//           <option value="file">Download File</option>
//         </select>
//       </div>

//       {/* Output Preview (text only, no QR image) */}
//       <div className="bg-white p-2 rounded border border-dashed border-green-300 text-xs text-gray-600">
//         <div className="font-mono text-green-700">
//           qrCode: data:image/png;base64,iVBOR...
//         </div>
//         <div className="mt-1 text-[10px] italic">Available via API call</div>
//       </div>

//       {/* Usage Hint */}
//       <div className="text-[10px] text-gray-500 italic">
//         Person B calls http://localhost:5000/qr â†’ Gets QR data here
//       </div>
//     </div>
//   );
// };

// export default OutputNode;






// client/src/components/OutputNode/OutputNode.jsx
import React from "react";
import { Handle, Position } from "@xyflow/react";

const OutputNode = ({ data = {} }) => {
  const flowData = data.flowData || {};
  const endpoint = flowData.endpoint || "/";
  const baseUrl = ""; // Dynamic later

  return (
    <div className="relative flex flex-col gap-3 p-4 bg-gradient-to-b from-green-50 to-white border-2 border-green-400 rounded-xl shadow-md w-[260px]">
      <Handle type="target" position={Position.Top} className="!bg-green-500 w-3 h-3" />
      
      <div className="flex items-center gap-2">
        <div className="w-2 h-2 bg-green-500 rounded-full"></div>
        <h4 className="text-sm font-bold text-green-800">Flow Output</h4>
      </div>

      <div className="bg-white p-3 rounded border text-xs space-y-2">
        <div className="font-mono text-green-700 text-[10px] break-all">
          <strong>API Endpoint:</strong><br />
          {baseUrl}{endpoint}
        </div>
        
        <div className="text-gray-600">
          <strong>Response Format:</strong>
          <pre className="mt-1 p-2 bg-gray-50 rounded text-[9px]">
{`{
  "success": true,
  "qrCode": "data:image/png;base64,...",
  "timestamp": "..."
}`}
          </pre>
        </div>
      </div>

      <div className="text-[10px] text-gray-500 italic">
        User B calls this endpoint â†’ Gets QR code
      </div>
    </div>
  );
};

export default OutputNode;

================================================================================
FILE: client\src\features\connect\components\ConnectForm.jsx
================================================================================


// client/src/features/connect/components/ConnectForm.jsx


import React, { useState, useRef, useEffect } from "react";
import { ChevronDown, Check } from "lucide-react";
import { createRoute } from "../services/ConnectService";

const ConnectForm = ({ setRoutes }) => {
  const [selectedMethods, setSelectedMethods] = useState([]);
  const [path, setPath] = useState("/");
  const [error, setError] = useState(null);
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const dropdownRef = useRef(null);

  const methods = ["GET", "POST", "PUT", "PATCH", "DELETE"];

  // Fetch all existing routes on mount
  useEffect(() => {
    const fetchExistingRoutes = async () => {
      try {
        // const response = await fetch("/api/routes");
        const response = await fetch(
          "https://cerlia-playground.onrender.com/routes"
        );

        if (!response.ok) throw new Error("Failed to fetch routes");
        const data = await response.json();
        setRoutes(data); // Set routes array directly
      } catch (err) {
        console.error("Error loading existing routes:", err);
        setError("Failed to load routes. Is the server running?");
      }
    };
    fetchExistingRoutes();
  }, [setRoutes]);

  // Close dropdown on outside click
  useEffect(() => {
    const handleClickOutside = (e) => {
      if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
        setDropdownOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const toggleMethod = (method) => {
    setSelectedMethods((prev) =>
      prev.includes(method)
        ? prev.filter((m) => m !== method)
        : [...prev, method]
    );
  };

  const handlePathChange = (e) => {
    const input = e.target.value;
    setPath(input.startsWith("/") ? input : "/" + input);
  };

  const handleConnect = async () => {
    if (!path || path === "/" || selectedMethods.length === 0) {
      setError("Please enter a valid path and select at least one method.");
      return;
    }

    try {
      const data = await createRoute(path, selectedMethods);
      setRoutes(data); // Set routes array directly
      setSelectedMethods([]);
      setPath("/");
      setError(null);
    } catch (err) {
      setError(err.message);
      console.error("Error in handleConnect:", err);
    }
  };

  return (
    <div className="flex flex-col gap-6 rounded-lg p-6">
      <h2 className="text-2xl font-bold tracking-wide text-fuchsia-200">
        Your API Endpoints
      </h2>
      <div className="flex flex-col gap-2">
        <label className="text-base font-medium text-white tracking-wide">
          Path
        </label>
        <input
          type="text"
          value={path}
          onChange={handlePathChange}
          className="h-[45px] bg-white/10 border border-white/20 text-white px-4 py-2 rounded-xl w-full md:w-[300px] placeholder-white/50 backdrop-blur-sm focus:outline-none focus:border-white focus:ring-2 focus:ring-white/50"
          placeholder="/example"
        />
      </div>
      <div className="flex flex-col gap-2">
        <p className="text-lg font-semibold text-white">Method</p>
        <div ref={dropdownRef} className="relative w-[300px]">
          <button
            onClick={() => setDropdownOpen((prev) => !prev)}
            className="bg-gray-800 text-white border border-gray-600 h-[40px] px-4 py-2 w-full rounded-lg flex items-center justify-between text-sm font-medium"
          >
            <span>Select</span>
            <ChevronDown className="w-4 h-4" />
          </button>
          {dropdownOpen && (
            <div className="absolute z-10 mt-2 w-full bg-gray-900 border border-gray-700 rounded-lg shadow-lg max-h-[200px] overflow-y-auto">
              {methods.map((method) => (
                <div
                  key={method}
                  onClick={() => toggleMethod(method)}
                  className={`
                    flex items-center justify-between px-4 py-2 text-sm cursor-pointer rounded-md
                    transition-all duration-200
                    ${
                      selectedMethods.includes(method)
                        ? "border border-fuchsia-500/50 bg-gray-800 text-white"
                        : "border border-transparent text-gray-300 hover:bg-gray-700"
                    }
                  `}
                >
                  <span className="font-medium">{method}</span>
                  {selectedMethods.includes(method) && (
                    <Check className="w-4 h-4 text-fuchsia-300" />
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
        {selectedMethods.length > 0 && (
          <div className="mt-1 text-sm text-gray-400">
            Selected: {selectedMethods.join(", ")}
          </div>
        )}
      </div>
      <div className="flex justify-center">
        <button
          onClick={handleConnect}
          className="cursor-pointer h-[50px] w-[120px] rounded-md font-semibold text-sm
            bg-gradient-to-r from-violet-600 to-fuchsia-600 text-white
            shadow-md hover:scale-105 transition-all duration-200 ease-in-out
            hover:shadow-fuchsia-500/50 focus:outline-none focus:ring-2 focus:ring-violet-400 focus:ring-opacity-70"
        >
          Connect
        </button>
      </div>
      {error && <div className="text-red-500 text-sm">{error}</div>}
    </div>
  );
};

export default ConnectForm;

================================================================================
FILE: client\src\features\connect\components\RestTriggers.jsx
================================================================================



// client/src/features/connect/components/RestTriggers.jsx
const RestTriggers = ({ routes }) => {
  return (
    <div className="bg-gray-900 p-4 rounded-md">
      <h3 className="text-lg font-semibold mb-2">REST Triggers</h3>

      {routes && routes.length > 0 ? (
        <div
          className="max-h-96 overflow-y-auto "
          // style={{
          //   scrollbarWidth: "thin" /* Firefox */,
          //   scrollbarColor: "#a78bfa transparent" /* Firefox */,
          // }}
        >
          <div className="space-y-4">
            {routes.map((route, idx) => (
              <div key={idx} className="bg-gray-800 p-3 rounded-md">
                <p className="font-mono text-purple-400">Path: {route.path}</p>
                <ul className="list-disc pl-6 mt-1 text-sm">
                  {route.methods.map((method, mIdx) => (
                    <li key={mIdx} className="capitalize">
                      {method}
                    </li>
                  ))}
                </ul>
              </div>
            ))}
          </div>
        </div>
      ) : (
        <p className="text-md text-gray-400">No routes created yet.</p>
      )}
    </div>
  );
};

export default RestTriggers;

================================================================================
FILE: client\src\features\connect\pages\Connect.jsx
================================================================================



// client/src/features/connect/pages/Connect.jsx

import React, { useState } from "react";
import RestTriggers from "../components/RestTriggers";
import ConnectForm from "../components/ConnectForm";

const Connect = () => {
  const [routes, setRoutes] = useState([]);

  return (
    <div className="bg-gray-900 text-white rounded-lg p-6 w-[95%] max-w-5xl shadow-lg">
      <div className="flex flex-col md:flex-row gap-4">
        {/* Left: Triggers */}
        <div className="md:w-2/5 w-full">
          <RestTriggers routes={routes} />
        </div>

        <div className="w-[0.5px] bg-gray-700 mx-4" />

        {/* Right: Form */}
        <div className="flex flex-col w-full md:w-2/3 overflow-y-scroll max-h-screen">
          <div className="text-center">
            <h1 className="text-[50px] md:text-[30px] font-medium tracking-widest bg-gradient-to-r from-purple-400 to-fuchsia-500 text-transparent bg-clip-text drop-shadow-lg">
              API Endpoint
            </h1>
            <p className="text-[16px] md:text-[20px] mt-4 font-mono text-gray-300">
              Define Path and HTTP method to test API instantly
            </p>
          </div>

          <ConnectForm setRoutes={setRoutes} />
        </div>
      </div>
    </div>
  );
};

export default Connect;


================================================================================
FILE: client\src\features\connect\services\ConnectService.jsx
================================================================================




// //client/src/features/connect/services/ConnectService.jsx
// export const createRoute = async (path, methods) => {
//   const response = await fetch("http://localhost:5000/api/create-route", {
//     method: "POST",
//     headers: { "Content-Type": "application/json" },
//     body: JSON.stringify({ path, methods }),
//   });

//   const data = await response.json();
//   if (!response.ok) throw new Error(data.error || "Failed to create routes");

//   // Fetch updated routes
//   const routesResponse = await fetch("http://localhost:5000/api/routes");
//   const routesData = await routesResponse.json();
//   if (!routesResponse.ok)
//     throw new Error(routesData.error || "Failed to fetch routes");

//   return routesData; // This returns { routes: [...] }
// };



// // client/src/features/connect/services/ConnectService.jsx
// export const createRoute = async (payload) => {
//   const response = await fetch("http://localhost:5000/api/create-route", {
//     method: "POST",
//     headers: { "Content-Type": "application/json" },
//     body: JSON.stringify(payload),
//   });

//   const data = await response.json();
//   if (!response.ok) {
//     throw new Error(data.message || "Failed to create route");
//   }

//   // refetch all routes to refresh the dashboard
//   const routesRes = await fetch("http://localhost:5000/api/routes");
//   const routes = await routesRes.json();
//   if (!routesRes.ok) {
//     throw new Error(routes.message || "Failed to fetch routes");
//   }

//   return routes;
// };




// // client/src/features/connect/services/ConnectService.jsx
// export const createRoute = async (path, methods) => {
//   // always build a real object; never send a raw string
//   const payload = {
//     path: path.startsWith("/") ? path : `/${path}`,
//     methods: Array.isArray(methods) ? methods : [methods],
//     serviceType: "qr-generator",
//     inputSchema: [{ name: "data", type: "string", required: true }],
//     outputSpec: { statusCode: 200 },
//   };

//   const res = await fetch("/create-route", {
//     method: "POST",
//     headers: { "Content-Type": "application/json" },
//     body: JSON.stringify(payload),        // âœ… valid JSON string
//   });

//   const data = await res.json().catch(() => ({}));
//   if (!res.ok) {
//     throw new Error(data.message || `Failed (${res.status})`);
//   }

//   // reload routes
//   const routesRes = await fetch("/api/routes");
//   const routes = await routesRes.json();
//   return routes;
// };



const BASE_URL = "https://cerlia-playground.onrender.com";

export const createRoute = async (path, methods) => {
  const payload = {
    path: path.startsWith("/") ? path : `/${path}`,
    methods: Array.isArray(methods) ? methods : [methods],
    serviceType: "qr-generator",
    inputSchema: [{ name: "data", type: "string", required: true }],
    outputSpec: { statusCode: 200 },
  };

  // CREATE ROUTE
  const res = await fetch(`${BASE_URL}/create-route`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });

  const data = await res.json().catch(() => ({}));
  if (!res.ok) {
    throw new Error(data.message || `Failed (${res.status})`);
  }

  // FETCH ALL ROUTES
  const routesRes = await fetch(`${BASE_URL}/routes`);
  const routes = await routesRes.json();

  return routes;
};

================================================================================
FILE: client\src\features\serviceNodes\components\ServicePopup.jsx
================================================================================

// client/src/features/serviceNodes/components/ServicePopup.jsx

// import React, { useState } from "react";
// import { useQRCode } from "../hooks/useQRCode.js";

// const utilities = [
//   { id: "qr-generator", name: "QR Code Generator" },
//   // future: { id: "pdf-generator", name: "PDF Generator" }, etc
// ];

// const ServicePopup = ({ onClose, onSelect }) => {
//   const [selected, setSelected] = useState(null);
//   const [qrText, setQrText] = useState("");
//   const [qrScale, setQrScale] = useState(4);
//   const qrCodeUrl = useQRCode(qrText, { scale: qrScale });

//   const handleSave = () => {
//     if (!selected) return;
//     let config = null;
//     if (selected === "qr-generator") {
//       if (!qrText) {
//         alert("Please enter a URL for the QR code.");
//         return;
//       }
//       config = { text: qrText, scale: qrScale };
//     }
//     // For future services, add config logic here based on selected
//     onSelect(selected, config);
//     onClose();
//   };

//   return (
//     <div className="fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center">
//       <div className="bg-white rounded-lg p-6 w-[400px] max-w-full shadow-lg relative">
//         <h2 className="text-xl font-bold mb-4">Add a Service</h2>
//         <ul className="space-y-3">
//           {utilities.map((u) => (
//             <li key={u.id}>
//               <button
//                 className={`w-full text-left px-4 py-2 rounded ${
//                   selected === u.id ? "bg-blue-500 text-white" : "bg-gray-100"
//                 }`}
//                 onClick={() => setSelected(u.id)}
//               >
//                 {u.name}
//               </button>
//             </li>
//           ))}
//         </ul>
//         {selected === "qr-generator" && (
//           <div className="mt-4">
//             <input
//               type="text"
//               placeholder="Enter URL for QR code"
//               value={qrText}
//               onChange={(e) => setQrText(e.target.value)}
//               className="w-full px-3 py-2 border rounded mb-3"
//             />
//             <input
//               type="number"
//               placeholder="Scale (default 4)"
//               value={qrScale}
//               onChange={(e) => setQrScale(Number(e.target.value))}
//               className="w-full px-3 py-2 border rounded mb-3"
//             />
//             {qrCodeUrl && (
//               <div className="flex justify-center">
//                 <img src={qrCodeUrl} alt="QR Code" className="w-32 h-32" />
//               </div>
//             )}
//           </div>
//         )}
//         <div className="mt-4 flex justify-end gap-3">
//           <button className="px-4 py-2 rounded bg-gray-300" onClick={onClose}>
//             Cancel
//           </button>
//           <button
//             className="px-4 py-2 rounded bg-blue-600 text-white"
//             onClick={handleSave}
//           >
//             Add
//           </button>
//         </div>
//       </div>
//     </div>
//   );
// };

// export default ServicePopup;






// // client/src/features/serviceNodes/components/ServicePopup.jsx
// import React, { useState } from "react";

// const services = [
//   { id: "qr-generator", name: "QR Code Generator" },
//   // later: { id: "pdf-generator", name: "PDF Generator" }, etc.
// ];

// const ServicePopup = ({ onClose, onSelect }) => {
//   const [selected, setSelected] = useState(null);

//   const handleAdd = () => {
//     if (!selected) return;
//     onSelect(selected);
//     onClose();
//   };

//   return (
//     <div className="fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center">
//       <div className="bg-white rounded-lg p-6 w-[400px] shadow-lg">
//         <h2 className="text-xl font-bold mb-4">Add a Service</h2>

//         <ul className="space-y-3">
//           {services.map((s) => (
//             <li key={s.id}>
//               <button
//                 onClick={() => setSelected(s.id)}
//                 className={`w-full text-left px-4 py-2 rounded ${
//                   selected === s.id ? "bg-blue-600 text-white" : "bg-gray-100"
//                 }`}
//               >
//                 {s.name}
//               </button>
//             </li>
//           ))}
//         </ul>

//         <div className="mt-5 flex justify-end gap-3">
//           <button
//             onClick={onClose}
//             className="px-4 py-2 bg-gray-300 rounded hover:bg-gray-400"
//           >
//             Cancel
//           </button>
//           <button
//             onClick={handleAdd}
//             className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
//           >
//             Add
//           </button>
//         </div>
//       </div>
//     </div>
//   );
// };

// export default ServicePopup;



// client/src/features/serviceNodes/components/ServicePopup.jsx
import React, { useState } from "react";

// âœ… Add 100s here easily - just ID, name, description
const services = [
  { id: "qr-generator", name: "QR Code Generator", desc: "Generate QR codes from URLs" },
  // Future additions:
  // { id: "pdf-generator", name: "PDF Generator", desc: "Create PDFs from HTML" },
  // { id: "email-sender", name: "Email Service", desc: "Send emails via SMTP" },
  // { id: "image-resize", name: "Image Resizer", desc: "Resize images" },
];

const ServicePopup = ({ onClose, onSelect }) => {
  const [selected, setSelected] = useState(null);

  const handleAdd = () => {
    if (!selected) return;
    onSelect(selected);
    onClose();
  };

  return (
    <div className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center">
      <div className="bg-gray-900 text-white rounded-xl p-6 w-[400px] shadow-2xl">
        <h2 className="text-xl font-bold mb-4">Add Service Node</h2>

        <ul className="space-y-2 max-h-96 overflow-y-auto">
          {services.map((s) => (
            <li key={s.id}>
              <button
                onClick={() => setSelected(s.id)}
                className={`w-full text-left px-4 py-3 rounded-lg transition ${
                  selected === s.id
                    ? "bg-purple-600 border-2 border-purple-400"
                    : "bg-gray-800 hover:bg-gray-700"
                }`}
              >
                <div className="font-medium">{s.name}</div>
                <div className="text-xs text-gray-400 mt-1">{s.desc}</div>
              </button>
            </li>
          ))}
        </ul>

        <div className="mt-5 flex justify-end gap-3">
          <button
            onClick={onClose}
            className="px-4 py-2 bg-gray-700 rounded-lg hover:bg-gray-600"
          >
            Cancel
          </button>
          <button
            onClick={handleAdd}
            disabled={!selected}
            className="px-4 py-2 bg-purple-600 rounded-lg hover:bg-purple-700 disabled:opacity-50"
          >
            Add Service
          </button>
        </div>
      </div>
    </div>
  );
};

export default ServicePopup;

================================================================================
FILE: client\src\features\serviceNodes\hooks\useQRCode.js
================================================================================

// //client/src/features/serviceNodes/hooks/useQRCode.js
// import { useMemo } from "react";
// import QRCode from "qrcode";

// export const useQRCode = (text) => {
//     const qrCodeUrl = useMemo(() => {
//         if (!text) return null;
//         try {
//             return QRCode.toDataURL(text);
//         } catch {
//             return null;
//         }
//     }, [text]);

//     return qrCodeUrl;
// };




// client/src/features/serviceNodes/hooks/useQRCode.js
import { useMemo } from "react";
import QRCode from "qrcode";

export const useQRCode = (text, options = {}) => {
    const qrCodeUrl = useMemo(() => {
        if (!text) return null;
        try {
            return QRCode.toDataURL(text, options);
        } catch {
            return null;
        }
    }, [text, JSON.stringify(options)]);

    return qrCodeUrl;
};

================================================================================
FILE: client\src\features\serviceNodes\pages\QRCodeService.jsx
================================================================================

//client/src/features/serviceNodes/pages/QRCodeService.jsx
import React, { useState } from "react";
import { useQRCode } from "../hooks/useQRCode.js";

const QRCodeService = () => {
  const [text, setText] = useState("");
  const qrCodeUrl = useQRCode(text);

  return (
    <div className="mt-4">
      <input
        type="text"
        placeholder="Enter text for QR code"
        value={text}
        onChange={(e) => setText(e.target.value)}
        className="w-full px-3 py-2 border rounded mb-3"
      />
      {qrCodeUrl && (
        <div className="flex justify-center">
          <img src={qrCodeUrl} alt="QR Code" className="w-32 h-32" />
        </div>
      )}
    </div>
  );
};

export default QRCodeService;

================================================================================
FILE: client\src\features\serviceNodes\services\qrCode\QRCodeNode.jsx
================================================================================

// // client/src/features/serviceNodes/services/qrCode/QRCodeNode.jsx
// import React, { useState } from "react";
// import { Handle } from "@xyflow/react";

// const QRCodeNode = ({ data = {} }) => {
//   const [schema, setSchema] = useState({
//     url: { type: "string", required: true, default: "" },
//     scale: { type: "number", required: false, default: 4, min: 1, max: 10 },
//   });

//   return (
//     <div className="bg-[#1E1E1E] text-white rounded-2xl p-4 w-[300px] shadow-xl border border-gray-700">
//       <div className="text-base font-semibold mb-3 flex items-center gap-2">
//         <span>ðŸ”² Generate QR Code</span>
//       </div>

//       {/* Schema Section - Buildship style */}
//       <div className="space-y-3">
//         <div className="text-xs text-gray-400 uppercase tracking-wide mb-2">
//           Input Schema
//         </div>

//         {/* URL Field */}
//         <div className="bg-gray-800/50 p-3 rounded border border-gray-700">
//           <div className="flex justify-between items-center mb-2">
//             <span className="text-sm text-gray-300">URL</span>
//             <span className="text-xs bg-orange-600 px-2 py-0.5 rounded">
//               {schema.url.required ? "Required" : "Optional"}
//             </span>
//           </div>
//           <input
//             type="text"
//             value={schema.url.default}
//             onChange={(e) =>
//               setSchema({
//                 ...schema,
//                 url: { ...schema.url, default: e.target.value },
//               })
//             }
//             placeholder="Value"
//             className="w-full px-3 py-2 rounded bg-gray-900 text-sm focus:outline-none border border-gray-700 focus:border-orange-500"
//           />
//           {!schema.url.default && schema.url.required && (
//             <div className="text-xs text-orange-500 mt-1">URL is required</div>
//           )}
//         </div>

//         {/* Scale Field */}
//         <div className="bg-gray-800/50 p-3 rounded border border-gray-700">
//           <div className="flex justify-between items-center mb-2">
//             <span className="text-sm text-gray-300">Scale</span>
//             <span className="text-xs bg-gray-600 px-2 py-0.5 rounded">
//               Optional
//             </span>
//           </div>
//           <input
//             type="number"
//             min={schema.scale.min}
//             max={schema.scale.max}
//             value={schema.scale.default}
//             onChange={(e) =>
//               setSchema({
//                 ...schema,
//                 scale: { ...schema.scale, default: Number(e.target.value) },
//               })
//             }
//             placeholder="Value"
//             className="w-full px-3 py-2 rounded bg-gray-900 text-sm focus:outline-none border border-gray-700"
//           />
//           {isNaN(schema.scale.default) && (
//             <div className="text-xs text-red-500 mt-1">
//               Scale is not a number
//             </div>
//           )}
//         </div>

//         {/* Output Info */}
//         <div className="mt-4 pt-3 border-t border-gray-700">
//           <div className="flex items-center gap-2 text-xs text-blue-400">
//             <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
//               <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
//               <path
//                 fillRule="evenodd"
//                 d="M4 8V6a6 6 0 1112 0v2h1a2 2 0 012 2v8a2 2 0 01-2 2H3a2 2 0 01-2-2v-8a2 2 0 012-2h1z"
//                 clipRule="evenodd"
//               />
//             </svg>
//             <span>ðŸ“„ Base64 QRCode File</span>
//           </div>
//           <div className="text-[10px] text-gray-500 mt-1">
//             Output will be passed to next node
//           </div>
//         </div>
//       </div>

//       {/* React Flow Handles */}
//       <Handle type="target" position="top" className="w-3 h-3" />
//       <Handle type="source" position="bottom" className="w-3 h-3" />
//     </div>
//   );
// };

// export default QRCodeNode;

















// // client/src/features/serviceNodes/services/qrCode/QRCodeNode.jsx
// import React, { useState } from "react";
// import { Handle, Position } from "@xyflow/react";  // Your existing imports

// const QRCodeNode = ({ data = {} }) => {
//   const [scale, setScale] = useState(data.scale || 4);
//   const [format, setFormat] = useState(data.format || "png");

//   // Simulate data flow from previous node (schema provides 'url')
//   const mockInputFromSchema = { url: "https://example.com" };  // In real: from edge data
//   const handleOutput = () => {
//     // Pass to output node (in real app, this triggers backend flow)
//     if (data.onOutput) {
//       data.onOutput({
//         input: mockInputFromSchema,
//         config: { scale, format },
//         output: { qrCode: "base64-placeholder" }  // Backend will fill this
//       });
//     }
//   };

//   return (
//     <div className="relative flex flex-col gap-3 p-4 bg-gradient-to-b from-purple-50 to-white border border-purple-200 rounded-xl shadow-md w-[240px] min-h-[140px] hover:shadow-lg transition-all">
//       <Handle type="target" position={Position.Top} className="!bg-purple-500 w-4 h-4" />
//       <Handle type="source" position={Position.Bottom} className="!bg-purple-500 w-4 h-4" />

//       {/* Title */}
//       <div className="flex items-center gap-2">
//         <div className="w-2 h-2 bg-purple-500 rounded-full"></div>
//         <h4 className="text-sm font-bold text-purple-800 tracking-wide">QR Service</h4>
//       </div>

//       {/* Input from Schema */}
//       <div className="bg-white p-2 rounded border border-purple-200 text-xs">
//         <div className="text-gray-600 mb-1">â† Input: url (string)</div>
//         <div className="font-mono text-purple-700 text-[11px]">{mockInputFromSchema.url}</div>
//       </div>

//       {/* Config - Scale & Format */}
//       <div className="space-y-2">
//         <label className="block text-[11px] text-gray-700 font-medium">Scale</label>
//         <select
//           value={scale}
//           onChange={(e) => setScale(Number(e.target.value))}
//           className="w-full px-2 py-1 text-xs border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-purple-500"
//         >
//           {[1,2,3,4,5,6,7,8,9,10].map((s) => <option key={s} value={s}>Size {s}</option>)}
//         </select>

//         <label className="block text-[11px] text-gray-700 font-medium">Format</label>
//         <select
//           value={format}
//           onChange={(e) => setFormat(e.target.value)}
//           className="w-full px-2 py-1 text-xs border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-purple-500"
//         >
//           <option value="png">PNG</option>
//           <option value="svg">SVG</option>
//           <option value="dataURL">Base64</option>
//         </select>
//       </div>

//       {/* Output to Next */}
//       <div className="bg-white p-2 rounded border border-dashed border-purple-300 text-xs">
//         <div className="text-gray-600">â†’ Output: qrCode (base64)</div>
//       </div>

//       <button
//         onClick={handleOutput}
//         className="text-[10px] text-purple-600 hover:text-purple-800 mt-1"
//       >
//         Process Flow â†’
//       </button>
//     </div>
//   );
// };

// export default QRCodeNode;




// client/src/features/serviceNodes/services/qrCode/QRCodeNode.jsx
import React, { useState } from "react";
import { Handle, Position } from "@xyflow/react";

const QRCodeNode = ({ data = {} }) => {
  const [scale, setScale] = useState(data.config?.scale || 4);
  const [format, setFormat] = useState(data.config?.format || "png");
  
  const flowData = data.flowData || {};
  const endpoint = flowData.endpoint || "/";
  const schemaInputs = flowData.schemaInputs || [];

  
  
  return (
    <div className="relative flex flex-col gap-3 p-4 bg-gradient-to-b from-purple-50 to-white border-2 border-purple-300 rounded-xl shadow-md w-[260px] hover:shadow-lg transition-all">
      <Handle type="target" position={Position.Top} className="!bg-purple-500 w-3 h-3" />
      <Handle type="source" position={Position.Bottom} className="!bg-purple-500 w-3 h-3" />

      <div className="flex items-center gap-2">
        <div className="w-2 h-2 bg-purple-500 rounded-full"></div>
        <h4 className="text-sm font-bold text-purple-800">Generate QR Code</h4>
      </div>

      {/* Shows input from schema */}
      <div className="bg-white p-2 rounded border border-purple-200 text-xs">
        <div className="text-gray-500 mb-1">â† Inputs from Schema:</div>
        {schemaInputs.length > 0 ? (
          schemaInputs.map((inp, i) => (
            <div key={i} className="text-purple-700 font-mono text-[10px]">
              â€¢ {inp.name} ({inp.type})
            </div>
          ))
        ) : (
          <div className="text-gray-400 italic">No inputs defined</div>
        )}
      </div>

      {/* Service Config */}
      <div className="space-y-2">
        <label className="block text-xs text-gray-700 font-medium">Scale</label>
        <select
          value={scale}
          onChange={(e) => setScale(Number(e.target.value))}
          className="w-full px-2 py-1 text-xs border rounded focus:outline-none focus:ring-1 focus:ring-purple-500"
        >
          {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((s) => (
            <option key={s} value={s}>
              {s}
            </option>
          ))}
        </select>

        <label className="block text-xs text-gray-700 font-medium">Format</label>
        <select
          value={format}
          onChange={(e) => setFormat(e.target.value)}
          className="w-full px-2 py-1 text-xs border rounded focus:outline-none focus:ring-1 focus:ring-purple-500"
        >
          <option value="png">PNG</option>
          <option value="svg">SVG</option>
          <option value="dataURL">Base64</option>
        </select>
      </div>

      {/* Output indicator */}
      <div className="bg-white p-2 rounded border border-dashed border-purple-300 text-xs">
        <div className="text-gray-500">â†’ Output: Base64 QR Code</div>
      </div>
    </div>
  );
};

export default QRCodeNode;

================================================================================
FILE: client\src\features\serviceNodes\services\qrCode\qrService.js
================================================================================

// Updated to call YOUR backend instead of client-side generation
// client/src/features/serviceNodes/services/qrCode/qrService.js
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || '';

/**
 * Generate QR code via YOUR backend BaaS
 * @param {string} text - URL or text to encode
 * @param {object} options - QR options (format, size, scale)
 * @returns {Promise<string|null>} - Base64 QR code or null
 */
// export const generateQRCode = async (text, options = {}) => {
//     try {
//         const response = await fetch(`${API_BASE_URL}/api/qr/generate`, {
//             method: 'POST',
//             headers: {
//                 'Content-Type': 'application/json',
//             },
//             body: JSON.stringify({
//                 data: text,
//                 format: options.format || 'png',
//                 size: options.size || 300,
//                 scale: options.scale || 4
//             })
//         });

//         if (!response.ok) {
//             const errorData = await response.json();
//             console.error('QR Generation failed:', errorData);
//             return null;
//         }

//         const result = await response.json();
//         return result.data.qrCode;

//     } catch (err) {
//         console.error('QR Code generation error:', err);
//         return null;
//     }
// };


export const generateQRCode = async (text, options = {}, endpoint = '/qr') => {
    try {
        const response = await fetch(`${API_BASE_URL}${endpoint}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ data: text, ...options }),
        });
        if (!response.ok) throw new Error('Failed to generate QR code');
        const result = await response.json();
        return result.data?.qrCode || null;
    } catch (err) {
        console.error('QR Code generation error:', err);
        return null;
    }
};

/**
 * Get QR generation stats from backend
 * @returns {Promise<object|null>}
 */
export const getQRStats = async () => {
    try {
        const response = await fetch(`${API_BASE_URL}/api/qr/stats`);
        if (!response.ok) return null;

        const result = await response.json();
        return result.data;
    } catch (err) {
        console.error('Failed to fetch QR stats:', err);
        return null;
    }
};

================================================================================
FILE: client\src\index.css
================================================================================

@import 'tailwindcss';
@plugin 'tailwind-scrollbar';
/* GLOBAL SCROLLBAR STYLES */

/* 1. Firefox */


/* 2. Webkit Browsers: Chrome, Edge, Brave, Safari */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: transparent; /* transparent track always */
}


::-webkit-scrollbar-thumb {
  background: linear-gradient(#0f0232 , #500739);
  border-radius: 10px;
}

/* âœ… This removes those ugly arrow buttons completely */
::-webkit-scrollbar-button {
  display: none;
  height: 0;
  width: 0;
}

================================================================================
FILE: client\src\main.jsx
================================================================================

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================================================================================
FILE: client\src\pages\Flow Builder\index.jsx
================================================================================

//client/src/pages/Flow Builder/index.jsx

import FlowBuilder from "../../components/FlowBuilder/FlowBuilder";

import React from 'react'

const RestTriggers = () => {
  return (
    <div>
        <FlowBuilder />
    </div>
  )
}

export default RestTriggers;

================================================================================
FILE: client\src\pages\auth\Login.jsx
================================================================================

// // Login.jsx
// import React from "react";

// const Login = () => {
//   const handleGoogleLogin = () => {
//     window.open("http://localhost:5000/api/auth/google", "_self");
//   };

//   return (
//     <div className="">
//       <div>
//         <h1 className="text-white text-3xl font-bold">Welcome to cerlia</h1>
//       </div>
//       <div className="min-h-screen flex items-center justify-center bg-[#090440] text-white">
//         <div className="bg-[#1e1b4b] p-10 rounded-xl shadow-lg text-center space-y-6">
//           <h1 className="text-3xl font-bold">Sign in with Google</h1>
//           <button
//             onClick={handleGoogleLogin}
//             className="px-6 py-2 bg-white text-black font-semibold rounded hover:bg-gray-200"
//           >
//             Continue with Google
//           </button>
//         </div>
//       </div>
//     </div>
//   );
// };

//client/src/pages/auth/Login.jsx
import React from "react";
import { LogIn } from "lucide-react"; // Keeping this import, though not used in the final button

const Login = () => {
  const handleGoogleLogin = () => {
    // Ensure this URL is correct for your backend
    // window.open("https://cerlia-playground.vercel.app/api/auth/google", "_self");
    // window.open("https://cerlia-playground-full.vercel.app/api/auth/google", "_self");
   
  window.open("https://cerlia-playground.onrender.com/auth/google", "_self");



  };

 

  return (
    // Main container with a deeper, more vibrant gradient background
    <div
      className="min-h-screen flex flex-col items-center justify-center 
                    bg-gradient-to-br from-gray-950 via-indigo-950 to-purple-950 
                    px-4 py-8 sm:py-12 font-inter"
    >
      {" "}
      {/* Added font-inter for a clean look */}
      {/* Main Title and Slogan */}
      <div className="text-center mb-10 sm:mb-12">
        <div className="text-center">
          <h1 className="text-2xl sm:text-3xl lg:text-4xl font-extrabold tracking-tight sm:tracking-wide leading-tight">
            <span className="bg-clip-text text-transparent bg-gradient-to-r from-white to-gray-300">
              Welcome to
            </span>
            <span className="font-extrabold text-purple-400 drop-shadow-xl animate-pulse">
              Snappy MVP
            </span>
          </h1>
          <p className="mt-4 text-md sm:text-lg max-w-2xl mx-auto font-medium text-gray-400">
            {/* Your creativity, powered by a smart workflow
            
            */}

            From Idea to Prototype, Fast and Effortless.
          </p>
        </div>
      </div>
      {/* Login Card Container - Enhanced Glassmorphism/Dark Theme */}
      <div
        className="w-full max-w-md 
                      bg-white/5 border border-white/10 
                      backdrop-blur-xl rounded-3xl 
                      p-8 sm:p-10 shadow-2xl shadow-indigo-900/40 
                      text-center space-y-8 sm:space-y-10 
                      transform transition-all duration-300 ease-in-out hover:scale-[1.01]"
      >
        {" "}
        {/* Subtle hover effect for the card */}
        {/* Sign In Title */}
        <h2
          className=" text-2xl sm:text-3xl font-bold text-white tracking-tight 
                       bg-gradient-to-r from-indigo-300 to-purple-300 text-transparent bg-clip-text"
        >
          Sign in to continue
        </h2>
        {/* Google Login Button - Significantly improved */}
        <button
          onClick={handleGoogleLogin}
          className="cursor-pointer flex items-center justify-center gap-4 w-full 
                     py-3.5 sm:py-4 px-6 
                     bg-white text-gray-900 font-semibold text-lg rounded-xl 
                     shadow-lg shadow-white/10 
                     transition-all duration-300 ease-in-out 
                     hover:bg-gray-100 hover:shadow-xl hover:shadow-white/20 
                     active:scale-[0.98] active:bg-gray-200 
                     focus:outline-none focus:ring-4 focus:ring-white/50 focus:ring-offset-2 focus:ring-offset-gray-900"
        >
          {/* Google Icon SVG - Slightly adjusted for better visual weight */}
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24" // Slightly larger for better visibility
            height="24"
            viewBox="0 0 48 48"
          >
            <path
              fill="#fbc02d"
              d="M43.6 20.5h-1.9V20H24v8h11.3c-1.6 4.6-6 8-11.3 8-6.6 0-12-5.4-12-12s5.4-12 12-12c3.1 0 5.9 1.2 8 3.1l5.7-5.7C34.1 7.6 29.3 6 24 6 12.9 6 4 14.9 4 26s8.9 20 20 20c11 0 20-8.9 20-20 0-1.2-.1-2.3-.4-3.5z"
            />
            <path
              fill="#e53935"
              d="M6.3 14.7l6.6 4.8C14.7 15.1 19 12 24 12c3.1 0 5.9 1.2 8 3.1l5.7-5.7C34.1 7.6 29.3 6 24 6c-7.5 0-14 3.4-18.3 8.7z"
            />
            <path
              fill="#4caf50"
              d="M24 46c5.3 0 10.1-1.9 13.8-5l-6.4-5.3C29.7 37.9 27 39 24 39c-5.3 0-9.7-3.4-11.3-8l-6.6 5C9.9 42.3 16.4 46 24 46z"
            />
            <path
              fill="#1565c0"
              d="M43.6 20.5H42V20H24v8h11.3c-1 2.8-3 5.2-5.7 6.7l6.4 5.3c-.5.4 7.3-5.3 7.3-14.5 0-1.2-.1-2.3-.4-3.5z"
            />
          </svg>
          <span>Continue with Google</span>
        </button>
        {/* Disclaimer Text */}
        <p className="text-gray-400 text-sm sm:text-base opacity-70">
          Youâ€™ll be redirected to Google for authentication.
        </p>
      </div>
    </div>
  );
};

export default Login;

================================================================================
FILE: client\src\shared\hooks\useDebounce.jsx
================================================================================



================================================================================
FILE: client\src\shared\lib\ApiClient.jsx
================================================================================



================================================================================
FILE: client\src\shared\lib\Helpers.jsx
================================================================================



================================================================================
FILE: client\src\state\hooks\useAuth.jsx
================================================================================

// //client/src/state/hooks/useAuth.jsx
// import { useEffect, useState, createContext, useContext } from "react";
// import axios from "axios";

// const AuthContext = createContext();

// export const AuthProvider = ({ children }) => {
//   const [user, setUser] = useState(null);
//   const [loading, setLoading] = useState(true);

//   const fetchUser = async () => {
//     // try {
//     //   const { data } = await axios.get("/api/auth/me", {
//     //     withCredentials: true,
//     //   });
//     try{
//       const {data } = await axios.get(
//   `${import.meta.env.VITE_SERVER_URL}/auth/me`,
//   { withCredentials: true }
//    });

 
//       setUser(data);
//     } catch (err) {
//       setUser(null);
//     } finally {
//       setLoading(false);
//     }
//   };

//   useEffect(() => {
//     fetchUser();
//   }, []);

//   return (
//     <AuthContext.Provider value={{ user, isAuthenticated: !!user, loading }}>
//       {children}
//     </AuthContext.Provider>
//   );
// };

// export const useAuth = () => useContext(AuthContext);\


// client/src/state/hooks/useAuth.jsx
import { useEffect, useState, createContext, useContext } from "react";
import axios from "axios";

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  const fetchUser = async () => {
    try {
      const { data } = await axios.get(
        `${import.meta.env.VITE_SERVER_URL}/auth/me`,
        { withCredentials: true }
      );

      setUser(data);
    } catch (err) {
      setUser(null);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchUser();
  }, []);

  return (
    <AuthContext.Provider value={{ user, isAuthenticated: !!user, loading }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext);


================================================================================
FILE: client\src\state\slices\authSlice.js
================================================================================



================================================================================
FILE: client\src\state\slices\connectSlice.js
================================================================================



================================================================================
FILE: client\src\state\slices\flowBuilderSlice.js
================================================================================



================================================================================
FILE: client\src\state\slices\outputSlice.js
================================================================================



================================================================================
FILE: client\src\state\slices\schemaSlice.js
================================================================================



================================================================================
FILE: client\src\state\slices\serviceNodeSlice.js
================================================================================



================================================================================
FILE: client\tailwind.config.js
================================================================================

import scrollbar from 'tailwind-scrollbar'

export default {
    content: ['./src/**/*.{js,jsx,ts,tsx}', './public/index.html'], // make sure paths are correct
    theme: {
        extend: {},
    },
    plugins: [scrollbar],
}


================================================================================
FILE: client\vite.config.js
================================================================================

// import { defineConfig } from 'vite'
// import react from '@vitejs/plugin-react';
// import tailwindcss from '@tailwindcss/vite';

// // https://vite.dev/config/
// export default defineConfig({
//   plugins: [react(),tailwindcss(),
//     { nocompatible: true }
//   ]
// })



import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";

export default defineConfig({
  root: ".",              // ensure Vercel understands root
  base: "/",              // required for Vercel, avoids 404
  plugins: [react(), tailwindcss()],
  build: {
    outDir: "dist",       // Vercel expects dist folder
    emptyOutDir: true
  },
  publicDir: "public"     // required so Vercel copies assets
});

================================================================================
FILE: server\config\db.js
================================================================================

//server/config/db.js
import mongoose from 'mongoose';

const connectDB = async () => {
    try {
        await mongoose.connect(process.env.MONGO_URI);
        console.log("âœ… MongoDB Connected");
    } catch (err) {
        console.error("âŒ MongoDB Error:", err);
        process.exit(1);
    }
};

export default connectDB;


// server/config/db.js
// import mongoose from 'mongoose';

// const MONGO_URI = process.env.MONGO_URI;
// if (!MONGO_URI) throw new Error("âŒ Missing MONGO_URI in environment variables");

// let isConnected = false;

// const connectDB = async () => {
//   if (isConnected) return; // reuse existing connection

//   try {
//     const conn = await mongoose.connect(MONGO_URI);
//     isConnected = conn.connections[0].readyState === 1;
//     console.log("âœ… MongoDB Connected");
//   } catch (err) {
//     console.error("âŒ MongoDB Error:", err);
//   }
// };

// export default connectDB;

================================================================================
FILE: server\config\passport.js
================================================================================

// const GoogleStrategy = require("passport-google-oauth20").Strategy;
// const passport = require("passport");
// const User = require("../models/userModel");

// passport.use(
//     new GoogleStrategy(
//         {
//             clientID: process.env.GOOGLE_CLIENT_ID,
//             clientSecret: process.env.GOOGLE_CLIENT_SECRET,
//             callbackURL: `${ process.env.SERVER_URL }/api/auth/google/callback`,
//         },
//         async (accessToken, refreshToken, profile, done) => {
//             const existingUser = await User.findOne({ googleId: profile.id });
//             if (existingUser) return done(null, existingUser);

//             const user = new User({
//                 googleId: profile.id,
//                 name: profile.displayName,
//                 email: profile.emails[0].value,
//                 photo: profile.photos[0].value,
//             });

//             await user.save();
//             done(null, user);
//         }
//     )
// );

// passport.serializeUser((user, done) => done(null, user.id));
// passport.deserializeUser((id, done) => {
//     User.findById(id).then((user) => done(null, user));
// });

//server/config/passport.js
import passport from "passport";
import { Strategy as GoogleStrategy } from "passport-google-oauth20";


import User from "../models/userModel.js";
import dotenv from 'dotenv';
dotenv.config();
const GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID
console.log(GOOGLE_CLIENT_ID)

passport.use(
    new GoogleStrategy(
        {
            clientID: process.env.GOOGLE_CLIENT_ID,
            clientSecret: process.env.GOOGLE_CLIENT_SECRET,
            // callbackURL: `${process.env.SERVER_URL}/api/auth/google/callback`,
            callbackURL: `${process.env.SERVER_URL}/auth/google/callback`,

        },
        async (accessToken, refreshToken, profile, done) => {
            const existingUser = await User.findOne({ googleId: profile.id });
            if (existingUser) return done(null, existingUser);

            const user = new User({
                googleId: profile.id,
                name: profile.displayName,
                email: profile.emails[0].value,
                photo: profile.photos[0].value,
            });

            await user.save();
            done(null, user);
        }
    )
);

passport.serializeUser((user, done) => done(null, user.id));

passport.deserializeUser((id, done) => {
    User.findById(id).then((user) => done(null, user));
});

================================================================================
FILE: server\config\session.js
================================================================================

// //server/config/session.js
// import session from 'express-session';


// const sessionConfig = session({
//     secret: process.env.SESSION_SECRET,
//     resave: false,
//     saveUninitialized: false,
//     rolling: true, // refresh cookie expiration on each request
//     cookie: {
//         maxAge: 6 * 60 * 60 * 1000, // 6 hours
//         secure: false, // true in prod with HTTPS
//         httpOnly: true,
//         sameSite: "lax",
//     },
// });

// export default sessionConfig;


import session from "express-session";

const sessionConfig = session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  rolling: true,
  cookie: {
    maxAge: 6 * 60 * 60 * 1000, // 6 hours
    secure: true,               // must be true in production with HTTPS
    httpOnly: true,
    sameSite: "none",           // must be 'none' for cross-site cookies
  },
 
});

export default sessionConfig;

================================================================================
FILE: server\controllers\apiController.js
================================================================================



// server/controllers/apiController.js
//validateData.js or controller file
function validateData(data, schema) {
    const errors = [];

    for (const field of schema) {
        const value = data[field.name];
        const fieldName = field.name;

        // Check if required
        if (field.required && (value === undefined || value === null || value === "")) {
            errors.push(`${fieldName} is required`);
            continue;
        }

        // Skip validation if value is optional and missing
        if (!field.required && value === undefined) continue;

        // Type validation
        switch (field.type) {
            case "string":
                if (typeof value !== "string") errors.push(`${fieldName} must be a string`);
                break;

            case "number":
                if (typeof value !== "number") errors.push(`${fieldName} must be a number`);
                if (field.min !== undefined && value < field.min)
                    errors.push(`${fieldName} must be at least ${field.min}`);
                if (field.max !== undefined && value > field.max)
                    errors.push(`${fieldName} must be at most ${field.max}`);
                break;

            case "boolean":
                if (typeof value !== "boolean") errors.push(`${fieldName} must be a boolean`);
                break;

            default:
                errors.push(`Unknown type for ${fieldName}`);
        }
    }

    return errors;
}

// Simulated dynamic schema map (you can replace this with DB later)
const routeSchemas = {
    "/posts": [
        { name: "title", type: "string", required: true },
        { name: "views", type: "number", min: 0 },
        { name: "isPublished", type: "boolean", default: false },
    ],
};

function getSchemaForRoute(path) {
    // Can add path normalization logic
    return routeSchemas[path] || [];
}

// Handlers
function get(req, res) {
    res.json({
        message: `GET request to ${req.originalUrl}`,
        data: [],
    });
}

function post(req, res) {
    const schema = getSchemaForRoute(req.path);
    const errors = validateData(req.body, schema);

    if (errors.length > 0) {
        return res.status(400).json({ message: "Validation failed", errors });
    }

    res.status(201).json({
        message: `POST request to ${req.originalUrl}`,
        data: req.body,
    });
}

function put(req, res) {
    const schema = getSchemaForRoute(req.path);
    const errors = validateData(req.body, schema);

    if (errors.length > 0) {
        return res.status(400).json({ message: "Validation failed", errors });
    }

    res.json({
        message: `PUT request to ${req.originalUrl}`,
        id: req.params.id,
        data: req.body,
    });
}

function patch(req, res) {
    const schema = getSchemaForRoute(req.path);
    const errors = validateData(req.body, schema);

    if (errors.length > 0) {
        return res.status(400).json({ message: "Validation failed", errors });
    }

    res.json({
        message: `PATCH request to ${req.originalUrl}`,
        id: req.params.id,
        data: req.body,
    });
}

function del(req, res) {
    res.json({
        message: `DELETE request to ${req.originalUrl}`,
        id: req.params.id,
    });
}

// Export as named exports
export { get, post, put, patch, del as delete };


================================================================================
FILE: server\controllers\authController.js
================================================================================

// exports.getUser = (req, res) => {
//     if (req.user) {
//         res.status(200).json(req.user);
//     } else {
//         res.status(401).json({ message: "Not authenticated" });
//     }
// };

// exports.logout = (req, res) => {
//     req.logout(() => {
//         res.redirect(process.env.CLIENT_URL);
//     });
// };


//server/controllers/authController.js
import dotenv from 'dotenv'
dotenv.config();
function getUser(req, res) {
    if (req.user) {
        res.status(200).json(req.user);
    } else {
        res.status(401).json({ message: "Not authenticated" });
    }
}

function logout(req, res) {
    req.logout(() => {
        res.redirect(process.env.CLIENT_URL);
    });
}

export { getUser, logout };

================================================================================
FILE: server\controllers\services\qrController.js
================================================================================

// server/controllers/services/qrController.js

import QRCode from 'qrcode';
import QRCodeModel from '../../models/services/qrCodeModel.js';


/**
 * @desc    Generate QR code
 * @route   POST /api/qr/generate
 * @access  Public (no auth for MVP)
 */
export const generateQRCode = async (req, res) => {
    try {
        const { data, format = 'png', size = 300, scale = 4 } = req.body;

        // Validation
        if (!data) {
            return res.status(400).json({
                success: false,
                message: 'Data is required to generate QR code'
            });
        }

        // QR generation options
        const qrOptions = {
            width: size,
            scale: Number(scale),
            margin: 1,
            color: {
                dark: '#000000',
                light: '#FFFFFF'
            },
            errorCorrectionLevel: 'M'
        };

        let qrResult;

        // Generate based on format
        switch (format) {
            case 'svg':
                qrResult = await QRCode.toString(data, { ...qrOptions, type: 'svg' });
                break;
            case 'png':
            case 'dataURL':
            default:
                qrResult = await QRCode.toDataURL(data, qrOptions);
        }

        // Save to database for tracking (optional)
        try {
            await QRCodeModel.create({
                data,
                format,
                size,
                scale,
                userId: req.user?._id, // if auth is enabled later
                ipAddress: req.ip
            });
        } catch (dbError) {
            console.warn('Failed to save QR to DB:', dbError.message);
            // Don't fail the request if DB save fails
        }

        // Success response
        res.status(200).json({
            success: true,
            data: {
                qrCode: qrResult,
                format,
                size,
                scale,
                timestamp: new Date().toISOString()
            }
        });

    } catch (error) {
        console.error('QR Generation Error:', error);
        res.status(500).json({
            success: false,
            message: 'Error generating QR code',
            error: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
};

/**
 * @desc    Get QR code generation stats
 * @route   GET /api/qr/stats
 * @access  Public
 */
export const getQRStats = async (req, res) => {
    try {
        const totalQRs = await QRCodeModel.countDocuments();

        const today = new Date();
        today.setHours(0, 0, 0, 0);

        const todayQRs = await QRCodeModel.countDocuments({
            createdAt: { $gte: today }
        });

        const formatStats = await QRCodeModel.aggregate([
            { $group: { _id: '$format', count: { $sum: 1 } } }
        ]);

        res.status(200).json({
            success: true,
            data: {
                totalQRCodes: totalQRs,
                todayQRCodes: todayQRs,
                formatBreakdown: formatStats
            }
        });
    } catch (error) {
        console.error('Stats Error:', error);
        res.status(500).json({
            success: false,
            message: 'Error fetching stats'
        });
    }
};

================================================================================
FILE: server\models\apiModel\apiModel.js
================================================================================

// //server/models/apiModel/apiModel.js
// import mongoose from 'mongoose';

// const RouteSchema = new mongoose.Schema({
//     path: { type: String, required: true, unique: true },
//     methods: [{ type: String, enum: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'], required: true }],
// }, { timestamps: true });

// export default mongoose.model('Route', RouteSchema);


// server/models/apiModel/apiModel.js
import mongoose from 'mongoose';

const RouteSchema = new mongoose.Schema({
    path: { type: String, required: true, unique: true },
    methods: [{ type: String, enum: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'], required: true }],
    serviceType: { type: String, default: null }, // e.g. "qr-generator", "chatgpt"
    inputSchema: { type: Array, default: [] },     // store the array of fields
    outputSpec: {                                     // store response/format metadata
        statusCode: { type: Number, default: 200 },
        bodyExample: { type: mongoose.Schema.Types.Mixed, default: {} },
        cacheTimeSec: { type: Number, default: 0 }
    }
}, { timestamps: true });

export default mongoose.model('Route', RouteSchema);

================================================================================
FILE: server\models\services\qrCodeModel.js
================================================================================

// server/models/services/qrCodeModel.js
import mongoose from 'mongoose';

const qrCodeSchema = new mongoose.Schema({
    data: {
        type: String,
        required: true
    },
    format: {
        type: String,
        enum: ['png', 'svg', 'dataURL'],
        default: 'png'
    },
    size: {
        type: Number,
        default: 300
    },
    scale: {
        type: Number,
        default: 4
    },
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: false
    },
    ipAddress: {
        type: String
    }
}, { timestamps: true });

const QRCodeModel = mongoose.model('QRCode', qrCodeSchema);

export default QRCodeModel;

================================================================================
FILE: server\models\userModel.js
================================================================================

// const mongoose = require("mongoose");

// const userSchema = new mongoose.Schema({
//     googleId: String,
//     name: String,
//     email: String,
//     photo: String,
// });

// module.exports = mongoose.model("User", userSchema);


//server/models/userModel.js
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
    googleId: String,
    name: String,
    email: String,
    photo: String,
});

const User = mongoose.model("User", userSchema);

export default User;

================================================================================
FILE: server\package.json
================================================================================

{
  "name": "server",
  "version": "1.0.0",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
     "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "body-parser": "^2.2.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "express-session": "^1.18.2",
    "mongoose": "^8.17.0",
    "nodemon": "^3.1.10",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "qrcode": "^1.5.4",
    "serverless-http": "^4.0.0"
  }
}

================================================================================
FILE: server\routes.json
================================================================================

[
  {
    "path": "/hello",
    "methods": [
      "GET"
    ]
  },
  {
    "path": "/kljkl",
    "methods": [
      "GET",
      "POST"
    ]
  },
  {
    "path": "/dsa",
    "methods": [
      "GET",
      "POST"
    ]
  },
  {
    "path": "/ksdjldsjkljdslk",
    "methods": [
      "GET",
      "PUT"
    ]
  },
  {
    "path": "/new",
    "methods": [
      "GET",
      "POST"
    ]
  },
  {
    "path": "/kl",
    "methods": [
      "GET"
    ]
  },
  {
    "path": "/fs",
    "methods": [
      "GET",
      "POST"
    ]
  },
  {
    "path": "/bh",
    "methods": [
      "GET"
    ]
  },
  {
    "path": "/nm",
    "methods": [
      "GET"
    ]
  },
  {
    "path": "/njk",
    "methods": [
      "GET"
    ]
  },
  {
    "path": "/jij",
    "methods": [
      "GET"
    ]
  },
  {
    "path": "/hhj",
    "methods": [
      "GET"
    ]
  },
  {
    "path": "/b",
    "methods": [
      "GET"
    ]
  },
  {
    "path": "/bf",
    "methods": [
      "GET",
      "POST"
    ]
  },
  {
    "path": "/fdssdf",
    "methods": [
      "GET"
    ]
  }
]

================================================================================
FILE: server\routes\authRoutes.js
================================================================================

// const express = require("express");
// const passport = require("passport");
// const { getUser, logout } = require("../controllers/authController");

// const router = express.Router();

// router.get(
//     "/google",
//     passport.authenticate("google", { scope: ["profile", "email"] })
// );

// router.get(
//     "/google/callback",
//     passport.authenticate("google", {
//         successRedirect: process.env.CLIENT_URL,
//         failureRedirect: "/login/failed",
//     })
// );

// router.get("/me", getUser);
// router.get("/logout", logout);

// module.exports = router;



//server/routes/authRoutes.js
import express from "express";
import passport from "passport";
import dotenv from 'dotenv'
dotenv.config();
import { getUser, logout } from "../controllers/authController.js";

const router = express.Router();

router.get(
    "/google",
    passport.authenticate("google", { scope: ["profile", "email"] })
);

// router.get(
//     "/google/callback",
//     passport.authenticate("google", {
//         successRedirect: process.env.CLIENT_URL,
//         failureRedirect: "/login/failed",
//     })
// );

router.get(
  "/google/callback",
  passport.authenticate("google", { failureRedirect: "/login/failed" }),
  (req, res) => {
    // â­ At this point the session is created and the Set-Cookie header is sent
    res.redirect(process.env.CLIENT_URL);
  }
);


router.get("/me", getUser);
router.get("/logout", logout);

export default router;

================================================================================
FILE: server\routes\dynamicRoutes.js
================================================================================



// import express from 'express';
// import routeService from '../services/routeService.js';

// const router = express.Router();

// // Endpoint to create dynamic routes
// router.post('/create-route', (req, res) => {
//     const { path, methods } = req.body;

//     if (!path || !methods || !Array.isArray(methods) || methods.length === 0) {
//         return res.status(400).json({ error: 'Path and at least one method are required' });
//     }

//     try {
//         const result = routeService.registerRoute(path, methods);
//         res.json(result);
//     } catch (error) {
//         res.status(500).json({ error: 'Failed to register routes' });
//     }
// });

// // Mount dynamic router
// router.use('/', routeService.getRouter());

// export default router;



// import express from 'express';
// import routeService from '../services/routeService.js';

// const router = express.Router();

// router.post('/create-route', (req, res) => {
//     const { path, methods } = req.body;
//     if (!path || !methods || !Array.isArray(methods) || methods.length === 0) {
//         return res.status(400).json({ error: 'Path and at least one method are required' });
//     }
//     try {
//         const result = routeService.registerRoute(path, methods);
//         res.json(result);
//     } catch (error) {
//         res.status(500).json({ error: 'Failed to register routes' });
//     }
// });

// router.use('/', routeService.getRouter());

// export default router;



// import express from 'express';
// import routeService from '../services/routeService.js';

// const router = express.Router();

// router.post('/create-route', (req, res) => {
//     const { path, methods } = req.body;
//     if (!path || !methods || !Array.isArray(methods) || methods.length === 0) {
//         return res.status(400).json({ error: 'Path and at least one method are required' });
//     }
//     try {
//         const result = routeService.registerRoute(path, methods);
//         res.json(result);
//     } catch (error) {
//         console.error('Error in /create-route:', error.message);
//         res.status(400).json({ error: error.message });
//     }
// });

// router.get('/routes', (req, res) => {
//     try {
//         res.json(routeService.getRoutes());
//     } catch (error) {
//         console.error('Error in /routes:', error.message);
//         res.status(500).json({ error: 'Failed to fetch routes' });
//     }
// });

// router.use('/', routeService.getRouter());

// export default router; 















// import express from 'express';
// import routeService from '../services/routeService.js';
// import RouteModel from '../models/apiModel/apiModel.js'; // Your mongoose model for routes
// const router = express.Router();

// router.post('/create-route', async (req, res) => {
//     const { path, methods } = req.body;

//     if (!path || !methods || !Array.isArray(methods) || methods.length === 0) {
//         return res.status(400).json({ error: 'Path and at least one method are required' });
//     }

//     try {
//         // Normalize path to always start with "/"
//         const normalizedPath = path.startsWith('/') ? path : `/${path}`;

//         // Check if the route already exists in DB
//         const existingRoute = await RouteModel.findOne({ path: normalizedPath });

//         if (existingRoute) {
//             return res.status(400).json({ error: `Route with path "${normalizedPath}" already exists.` });
//         }

//         // Save new route to MongoDB
//         const newRoute = new RouteModel({
//             path: normalizedPath,
//             methods,
//         });

//         await newRoute.save();

//         // Register route in memory to your routeService for express router
//         const result = routeService.registerRoute(normalizedPath, methods);

//         return res.json({
//             message: `Route ${normalizedPath} created successfully`,
//             ...result,
//         });
//     } catch (err) {
//         console.error('Error in /create-route:', err);
//         return res.status(500).json({ error: 'Internal server error' });
//     }
// });

// export default router;































// import express from 'express';
// import routeService from '../services/routeService.js';

// const router = express.Router();

// router.post('/create-route', async (req, res) => {
//     const { path, methods } = req.body;
//     if (!path || !methods || !Array.isArray(methods) || methods.length === 0) {
//         return res.status(400).json({ error: 'Path and at least one method are required' });
//     }
//     try {
//         const result = await routeService.registerRoute(path, methods);
//         res.json(result);
//     } catch (error) {
//         console.error('Error in /create-route:', error.message);
//         res.status(400).json({ error: error.message });
//     }
// });

// router.get('/routes', async (req, res) => {
//     try {
//         const routes = await routeService.getRoutes();
//         res.json({ routes });
//     } catch (error) {
//         console.error('Error in /routes:', error.message);
//         res.status(500).json({ error: 'Failed to fetch routes' });
//     }
// });

// router.use('/', routeService.getRouter());

// export default router;











// import express from 'express';
// import routeService from '../services/routeService.js';

// const router = express.Router();

// router.post('/create-route', async (req, res) => {
//     const { path, methods } = req.body;
//     if (!path || !methods || !Array.isArray(methods) || methods.length === 0) {
//         return res.status(400).json({ error: 'Path and at least one method are required' });
//     }
//     try {
//         const result = await routeService.registerRoute(path, methods);
//         res.json(result);
//     } catch (error) {
//         console.error('Error in /create-route:', error.message);
//         res.status(400).json({ error: error.message });
//     }
// });

// router.get('/routes', async (req, res) => {
//     try {
//         const routes = await routeService.getRoutes();
//         res.json(routes);
//     } catch (error) {
//         console.error('Error in /routes:', error.message);
//         res.status(500).json({ error: 'Failed to fetch routes' });
//     }
// });

// router.use('/', routeService.getRouter());

// export default router;




// // server/routes/dynamicRoutes.js - Your existing + QR flow handler
// import express from 'express';
// import { generateQRCode } from '../controllers/services/qrController.js';  // Your existing

// const router = express.Router();

// // Your existing dynamic route creation
// router.post('/create-route', async (req, res) => {
//     const { path, methods } = req.body;
//     // ... your existing logic to create dynamic routes

//     // For QR flow, auto-mount if path === '/qr'
//     if (path === '/qr' && methods.includes('POST')) {
//         router.post('/qr', generateQRCode);  // Mount your QR handler
//     }

//     res.json({ success: true, routes: [] });  // Your response
// });

// router.get('/routes', (req, res) => {
//     // Return current routes including /qr
//     res.json({ routes: [{ path: '/qr', methods: ['POST'] }] });
// });

// export default router;




// // server/routes/dynamicRoutes.js
// import express from 'express';
// import routeService from '../services/routeService.js';

// const router = express.Router();

// // âœ… Create new dynamic route
// router.post('/create-route', async (req, res) => {
//     try {
//         const { path, methods, serviceType } = req.body;
//         const result = await routeService.registerRoute(path, methods, serviceType);
//         res.json({ success: true, route: result });
//     } catch (error) {
//         res.status(400).json({ success: false, message: error.message });
//     }
// });

// // âœ… Get all existing routes
// router.get('/routes', async (req, res) => {
//     try {
//         const routes = await routeService.getRoutes();
//         res.json(routes);
//     } catch (error) {
//         res.status(500).json({ success: false, message: error.message });
//     }
// });

// export default router;



// server/routes/dynamicRoutes.js
import express from "express";
import routeService from "../services/routeService.js";

const router = express.Router();

// âœ… Create a new dynamic route
router.post("/create-route", async (req, res) => {
    try {
        const { path, methods, serviceType, inputSchema, outputSpec } = req.body;

        const result = await routeService.registerRoute(
            path,
            methods,
            serviceType,
            inputSchema || [],
            outputSpec || {}
        );

        res.json({ success: true, route: result });
    } catch (error) {
        console.error("âŒ Error creating route:", error.message);
        res.status(400).json({ success: false, message: error.message });
    }
});

// âœ… Get all existing routes
router.get("/routes", async (req, res) => {
    try {
        const routes = await routeService.getRoutes();
        res.json(routes);
    } catch (error) {
        console.error("âŒ Error fetching routes:", error.message);
        res.status(500).json({ success: false, message: error.message });
    }
});

export default router;

================================================================================
FILE: server\routes\services\qrRoutes.js
================================================================================

// server/routes/services/qrRoutes.js

import express from 'express';
import { generateQRCode, getQRStats } from '../../controllers/services/qrController.js';

const router = express.Router();

router.post('/generate', generateQRCode);
router.get('/stats', getQRStats);

export default router;

================================================================================
FILE: server\server.js
================================================================================

// import express from 'express';
// import cors from 'cors';
// import bodyParser from 'body-parser';
// import session from 'express-session';
// import passport from 'passport';
// import dotenv from 'dotenv';
// import mongoose from 'mongoose';
// dotenv.config(); // Load environment variables

// import dynamicRoutes from './routes/dynamicRoutes.js';
// import authRoutes from './routes/authRoutes.js';
// import './config/passport.js'; // Load passport strategy


// const app = express();
// const port = 5000;

// // Connect MongoDB
// mongoose.connect(process.env.MONGO_URI)
//   .then(() => console.log("âœ… MongoDB Connected"))
//   .catch((err) => console.log("âŒ MongoDB Error:", err));

// // Middlewares
// app.use(cors({
//   origin: process.env.CLIENT_URL,
//   credentials: true,
// }));

// app.use(bodyParser.json());


// // Session & Passport
// app.use(
//   session({
//     secret: process.env.SESSION_SECRET,
//     resave: false,
//     saveUninitialized: false,
//     rolling: true, // refresh cookie expiration on each request
//     cookie: {
//       maxAge: 6 * 60 * 60 * 1000, // 1 day in ms
//       secure: false, // set true in prod with HTTPS
//       httpOnly: true,
//       sameSite: "lax",
//     },
//   })
// );


// app.use(passport.initialize());
// app.use(passport.session());

// // Routes
// app.use('/api', dynamicRoutes);
// app.use('/api/auth', authRoutes);

// // Start server
// app.listen(port, () => {
//   console.log(`ðŸš€ Server running on http://localhost:${port}`);
// });




// // server/server.js
// import express from 'express';
// import cors from 'cors';
// import bodyParser from 'body-parser';
// import passport from 'passport';
// import dotenv from 'dotenv';





// import connectDB from './config/db.js';
// // import sessionConfig from './config/session.js';

// import dynamicRoutes from './routes/dynamicRoutes.js';
// import authRoutes from './routes/authRoutes.js';
// import qrRoutes from './routes/services/qrRoutes.js'
// import './config/passport.js';
// import sessionConfig from './config/session.js';
// import routeService from './services/routeService.js'; // ðŸ‘ˆ add this line

// dotenv.config();
// connectDB();

// const app = express();
// app.set("trust proxy", 1); // ðŸ”¥ REQUIRED for Secure Cookies on Render
// const port = process.env.PORT || 5000;

// // Middlewares
// const allowedOrigins = [
//   process.env.CLIENT_URL,
//   "http://localhost:5174"
// ];

// // app.use(cors({
// //   origin: function (origin, callback) {
// //     if (!origin || allowedOrigins.includes(origin)) {
// //       callback(null, true);
// //     } else {
// //       callback(new Error("Not allowed by CORS"));
// //     }
// //   },
// //   credentials: true,
// // }));

// // app.use(cors({
// //   origin: true,
// //   credentials: true
// // }));

// app.use(cors({
//   origin: process.env.CLIENT_URL,
//   credentials: true,
// }));


// app.use(bodyParser.json());

// // Sessions & Passport
// app.use(sessionConfig);
// app.use(passport.initialize());
// app.use(passport.session());

// // Routes
// app.use('', dynamicRoutes);
// app.use('/auth', authRoutes);

// app.use('/qr', qrRoutes);

// app.use(routeService.getRouter());

// // Start server
// app.listen(port, () => {
//   console.log(`ðŸš€ Server running on http://localhost:${port}`);
// });
// // export default app;




// server/server.js
import express from "express";
import cors from "cors";
import bodyParser from "body-parser";
import passport from "passport";
import dotenv from "dotenv";

import connectDB from "./config/db.js";
import dynamicRoutes from "./routes/dynamicRoutes.js";
import authRoutes from "./routes/authRoutes.js";
import qrRoutes from "./routes/services/qrRoutes.js";
import "./config/passport.js";
import sessionConfig from "./config/session.js";
import routeService from "./services/routeService.js";

dotenv.config();
connectDB();

const app = express();

// â­ MUST BE BEFORE SESSION â€” REQUIRED FOR SECURE COOKIES ON RENDER
app.set("trust proxy", true);

// â­ FIXED CORS â€” NO ARRAY (arrays break credentials)
// app.use(
//   cors({
//     origin: "https://cerlia-playground-frontend.onrender.com",
//     credentials: true,
//   })
// );

app.use(
  cors({
    origin: [
      "https://cerlia-playground-frontend.onrender.com",
      "https://cerlia-playground.onrender.com",
      "http://localhost:5173"
    ],
    credentials: true,
  })
);


app.use(bodyParser.json());

// â­ SESSION MUST COME AFTER trust proxy + CORS
app.use(sessionConfig);

app.use(passport.initialize());
app.use(passport.session());

// Routes
app.use("", dynamicRoutes);
app.use("/auth", authRoutes);
app.use("/qr", qrRoutes);
app.use(routeService.getRouter());

app.listen(process.env.PORT || 5000, () => {
  console.log("ðŸš€ Server running");
});

================================================================================
FILE: server\services\routeService.js
================================================================================



// import express from 'express';
// import * as apiController from '../controllers/apiController.js';

// class RouteService {
//     constructor() {
//         this.router = express.Router();
//         this.routes = new Map(); // In-memory store for route configs
//     }

//     registerRoute(path, methods) {
//         // Normalize path (ensure it starts with '/')
//         const normalizedPath = path.startsWith('/') ? path : `/${path}`;

//         // Store route configuration
//         this.routes.set(normalizedPath, methods);

//         // Register routes based on selected methods
//         if (methods.includes('GET')) {
//             this.router.get(normalizedPath, apiController.get);
//         }
//         if (methods.includes('POST')) {
//             this.router.post(normalizedPath, apiController.post);
//         }
//         if (methods.includes('PUT')) {
//             this.router.put(`${normalizedPath}/:id`, apiController.put);
//         }
//         if (methods.includes('PATCH')) {
//             this.router.patch(`${normalizedPath}/:id`, apiController.patch);
//         }
//         if (methods.includes('DELETE')) {
//             this.router.delete(`${normalizedPath}/:id`, apiController.delete);
//         }

//         return {
//             message: `Routes for ${normalizedPath} registered successfully`,
//             routes: methods.map(method => ({
//                 method,
//                 url: method === 'GET' || method === 'POST'
//                     ? `http://localhost:5000/api${normalizedPath}`
//                     : `http://localhost:5000/api${normalizedPath}/:id`
//             }))
//         };
//     }

//     getRouter() {
//         return this.router;
//     }
// }

// export default new RouteService();



// import express from 'express';
// import fs from 'fs';
// import path from 'path';
// import * as apiController from '../controllers/apiController.js';

// const DATA_FILE = path.resolve('./routes.json');

// class RouteService {
//     constructor() {
//         this.router = express.Router();
//         this.routes = new Map();

//         this.loadRoutesFromFile();
//     }

//     loadRoutesFromFile() {
//         if (fs.existsSync(DATA_FILE)) {
//             const saved = JSON.parse(fs.readFileSync(DATA_FILE, 'utf8'));
//             saved.forEach(({ path, methods }) => {
//                 this.routes.set(path, methods);
//                 this._register(path, methods);
//             });
//         }
//     }

//     saveRoutesToFile() {
//         const arr = Array.from(this.routes, ([path, methods]) => ({ path, methods }));
//         fs.writeFileSync(DATA_FILE, JSON.stringify(arr, null, 2));
//     }

//     _register(normalizedPath, methods) {
//         if (methods.includes('GET')) {
//             this.router.get(normalizedPath, apiController.get);
//         }
//         if (methods.includes('POST')) {
//             this.router.post(normalizedPath, apiController.post);
//         }
//         if (methods.includes('PUT')) {
//             this.router.put(`${normalizedPath}/:id`, apiController.put);
//         }
//         if (methods.includes('PATCH')) {
//             this.router.patch(`${normalizedPath}/:id`, apiController.patch);
//         }
//         if (methods.includes('DELETE')) {
//             this.router.delete(`${normalizedPath}/:id`, apiController.delete);
//         }
//     }

//     registerRoute(path, methods) {
//         const normalizedPath = path.startsWith('/') ? path : `/${path}`;
//         this.routes.set(normalizedPath, methods);
//         this._register(normalizedPath, methods);
//         this.saveRoutesToFile();

//         return { message: `Routes for ${normalizedPath} registered`, path: normalizedPath, methods };
//     }

//     getRoutes() {
//         return Array.from(this.routes, ([path, methods]) => ({ path, methods }));
//     }

//     getRouter() {
//         return this.router;
//     }
// }

// export default new RouteService();






// import express from 'express';
// import fs from 'fs';
// import path from 'path';
// import * as apiController from '../controllers/apiController.js';

// const DATA_FILE = path.resolve('./routes.json');

// class RouteService {
//     constructor() {
//         this.routes = new Map();
//         this.router = express.Router();
//         this.loadRoutesFromFile();
//     }

//     loadRoutesFromFile() {
//         if (fs.existsSync(DATA_FILE)) {
//             const saved = JSON.parse(fs.readFileSync(DATA_FILE, 'utf8'));
//             saved.forEach(({ path, methods }) => {
//                 this.routes.set(path, methods);
//             });
//             this.rebuildRouter();  // build router after loading
//         }
//     }

//     saveRoutesToFile() {
//         const arr = Array.from(this.routes, ([path, methods]) => ({ path, methods }));
//         fs.writeFileSync(DATA_FILE, JSON.stringify(arr, null, 2));
//     }

//     _register(normalizedPath, methods) {
//         if (methods.includes('GET')) {
//             this.router.get(normalizedPath, apiController.get);
//         }
//         if (methods.includes('POST')) {
//             this.router.post(normalizedPath, apiController.post);
//         }
//         if (methods.includes('PUT')) {
//             this.router.put(`${normalizedPath}/:id`, apiController.put);
//         }
//         if (methods.includes('PATCH')) {
//             this.router.patch(`${normalizedPath}/:id`, apiController.patch);
//         }
//         if (methods.includes('DELETE')) {
//             this.router.delete(`${normalizedPath}/:id`, apiController.delete);
//         }
//     }

//     rebuildRouter() {
//         this.router = express.Router();  // reset router instance
//         for (const [path, methods] of this.routes.entries()) {
//             this._register(path, methods);
//         }
//     }

//     registerRoute(path, methods) {
//         const normalizedPath = path.startsWith('/') ? path : `/${path}`;
//         this.routes.set(normalizedPath, methods);

//         this.rebuildRouter();  // important: rebuild router after adding new route
//         this.saveRoutesToFile();

//         return { message: `Routes for ${normalizedPath} registered`, path: normalizedPath, methods };
//     }

//     getRoutes() {
//         return Array.from(this.routes, ([path, methods]) => ({ path, methods }));
//     }

//     getRouter() {
//         return this.router;
//     }
// }

// export default new RouteService();






























// import express from 'express';
// import fs from 'fs';
// import path from 'path';
// import * as apiController from '../controllers/apiController.js';

// const DATA_FILE = path.resolve('./routes.json');

// class RouteService {
//     constructor() {
//         this.routes = new Map();
//         this.router = express.Router();  // create once, never replace

//         this.loadRoutesFromFile();
//     }

//     loadRoutesFromFile() {
//         if (fs.existsSync(DATA_FILE)) {
//             const saved = JSON.parse(fs.readFileSync(DATA_FILE, 'utf8'));
//             saved.forEach(({ path, methods }) => {
//                 this.routes.set(path, methods);
//                 this._register(path, methods);
//             });
//         }
//     }

//     saveRoutesToFile() {
//         const arr = Array.from(this.routes, ([path, methods]) => ({ path, methods }));
//         fs.writeFileSync(DATA_FILE, JSON.stringify(arr, null, 2));
//     }

//     _register(normalizedPath, methods) {
//         if (methods.includes('GET')) {
//             this.router.get(normalizedPath, apiController.get);
//         }
//         if (methods.includes('POST')) {
//             this.router.post(normalizedPath, apiController.post);
//         }
//         if (methods.includes('PUT')) {
//             this.router.put(`${normalizedPath}/:id`, apiController.put);
//         }
//         if (methods.includes('PATCH')) {
//             this.router.patch(`${normalizedPath}/:id`, apiController.patch);
//         }
//         if (methods.includes('DELETE')) {
//             this.router.delete(`${normalizedPath}/:id`, apiController.delete);
//         }
//     }

//     registerRoute(path, methods) {
//         const normalizedPath = path.startsWith('/') ? path : `/${path}`;
//         if (this.routes.has(normalizedPath)) {
//             throw new Error(`Route ${normalizedPath} already exists.`);
//         }

//         this.routes.set(normalizedPath, methods);
//         this._register(normalizedPath, methods);  // register new routes immediately
//         this.saveRoutesToFile();

//         return { message: `Routes for ${normalizedPath} registered`, path: normalizedPath, methods };
//     }

//     getRoutes() {
//         return Array.from(this.routes, ([path, methods]) => ({ path, methods }));
//     }

//     getRouter() {
//         return this.router;
//     }
// }

// export default new RouteService();













// import express from 'express';
// import mongoose from 'mongoose';
// import * as apiController from '../controllers/apiController.js';
// import Route from '../models/apiModel/apiModel.js';

// class RouteService {
//     constructor() {
//         this.routes = new Map();
//         this.router = express.Router();
//         this.loadRoutesFromDB();
//     }

//     async loadRoutesFromDB() {
//         try {
//             const savedRoutes = await Route.find();
//             savedRoutes.forEach(({ path, methods }) => {
//                 this.routes.set(path, methods);
//                 this._register(path, methods);
//             });
//             console.log('Routes loaded from MongoDB:', savedRoutes);
//         } catch (error) {
//             console.error('Error loading routes from DB:', error.message);
//         }
//     }

//     // async saveRoutesToDB(normalizedPath, methods) {
//     //     try {
//     //         await Route.create({ path: normalizedPath, methods });
//     //         console.log(`Route ${normalizedPath} saved to MongoDB`);
//     //     } catch (error) {
//     //         console.error('Error saving route to DB:', error.message);
//     //         throw new Error('Failed to save route to database');
//     //     }
//     // }

//     async saveRoutesToDB(normalizedPath, methods) {
//         try {
//             await Route.findOneAndUpdate(
//                 { path: normalizedPath },
//                 { methods: methods },
//                 { upsert: true, new: true, setDefaultsOnInsert: true }
//             );
//             console.log(`Route ${normalizedPath} saved/updated in MongoDB`);
//         } catch (error) {
//             console.error('Error saving route to DB:', error);
//             throw new Error('Failed to save route to database');
//         }
//     }


//     _register(normalizedPath, methods) {
//         if (methods.includes('GET')) {
//             this.router.get(normalizedPath, apiController.get);
//         }
//         if (methods.includes('POST')) {
//             this.router.post(normalizedPath, apiController.post);
//         }
//         if (methods.includes('PUT')) {
//             this.router.put(`${normalizedPath}/:id`, apiController.put);
//         }
//         if (methods.includes('PATCH')) {
//             this.router.patch(`${normalizedPath}/:id`, apiController.patch);
//         }
//         if (methods.includes('DELETE')) {
//             this.router.delete(`${normalizedPath}/:id`, apiController.delete);
//         }
//     }

//     async registerRoute(path, methods) {
//         const validMethods = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'];
//         if (!path || typeof path !== 'string' || path.includes(' ')) {
//             throw new Error('Invalid path');
//         }
//         if (!methods || !Array.isArray(methods) || methods.length === 0 || !methods.every(m => validMethods.includes(m))) {
//             throw new Error('Invalid or empty methods');
//         }

//         const normalizedPath = path.startsWith('/') ? path : `/${path}`;
//         if (this.routes.has(normalizedPath)) {
//             throw new Error(`Route ${normalizedPath} already exists`);
//         }

//         this.routes.set(normalizedPath, methods);
//         this._register(normalizedPath, methods);
//         await this.saveRoutesToDB(normalizedPath, methods);

//         return { message: `Routes for ${normalizedPath} registered`, path: normalizedPath, methods };
//     }

//     async getRoutes() {
//         try {
//             const routes = await Route.find();
//             return routes.map(({ path, methods }) => ({ path, methods }));
//         } catch (error) {
//             console.error('Error fetching routes from DB:', error.message);
//             return [];
//         }
//     }

//     getRouter() {
//         return this.router;
//     }
// }

// export default new RouteService();

// //server/services/routeService.js
// import express from 'express';
// import mongoose from 'mongoose';
// import * as apiController from '../controllers/apiController.js';
// import Route from '../models/apiModel/apiModel.js';
// import { generateQRCode } from '../controllers/services/qrController.js';

// class RouteService {
//     constructor() {
//         this.routes = new Map();
//         this.router = express.Router();
//         this.loadRoutesFromDB();
//     }

//     async loadRoutesFromDB() {
//         try {
//             const savedRoutes = await Route.find();
//             savedRoutes.forEach(({ path, methods }) => {
//                 this.routes.set(path, methods);
//                 this._register(path, methods);
//             });
//             console.log('Routes loaded from MongoDB:', savedRoutes);
//         } catch (error) {
//             console.error('Error loading routes from DB:', error.message);
//         }
//     }

//     async saveRoutesToDB(normalizedPath, methods) {
//         try {
//             await Route.create({ path: normalizedPath, methods });
//             console.log(`Route ${normalizedPath} saved to MongoDB`);
//         } catch (error) {
//             console.error('Error saving route to DB:', error.message);
//             throw new Error('Failed to save route to database');
//         }
//     }

//     // _register(normalizedPath, methods) {
//     //     if (methods.includes('GET')) {
//     //         this.router.get(normalizedPath, apiController.get);
//     //     }
//     //     if (methods.includes('POST')) {
//     //         this.router.post(normalizedPath, apiController.post);
//     //     }
//     //     if (methods.includes('PUT')) {
//     //         this.router.put(`${normalizedPath}/:id`, apiController.put);
//     //     }
//     //     if (methods.includes('PATCH')) {
//     //         this.router.patch(`${normalizedPath}/:id`, apiController.patch);
//     //     }
//     //     if (methods.includes('DELETE')) {
//     //         this.router.delete(`${normalizedPath}/:id`, apiController.delete);
//     //     }
//     // }

//     // _register(normalizedPath, methods, serviceType = null) {
//     //     // Bind standard REST handlers
//     //     if (methods.includes('GET')) {
//     //         this.router.get(normalizedPath, apiController.get);
//     //     }
//     //     if (methods.includes('POST')) {
//     //         // Special handling: if route is a QR service
//     //         if (serviceType === 'qr-generator') {
//     //             this.router.post(normalizedPath, generateQRCode);
//     //         } else {
//     //             this.router.post(normalizedPath, apiController.post);
//     //         }
//     //     }
//     //     if (methods.includes('PUT')) {
//     //         this.router.put(`${normalizedPath}/:id`, apiController.put);
//     //     }
//     //     if (methods.includes('PATCH')) {
//     //         this.router.patch(`${normalizedPath}/:id`, apiController.patch);
//     //     }
//     //     if (methods.includes('DELETE')) {
//     //         this.router.delete(`${normalizedPath}/:id`, apiController.delete);
//     //     }
//     // }


//     _register(normalizedPath, methods, serviceType = null) {
//         if (methods.includes("POST")) {
//             if (serviceType === "qr-generator") {
//                 this.router.post(normalizedPath, generateQRCode);
//             } else {
//                 this.router.post(normalizedPath, apiController.post);
//             }
//         }
//         if (methods.includes("GET")) this.router.get(normalizedPath, apiController.get);
//         if (methods.includes("PUT")) this.router.put(`${normalizedPath}/:id`, apiController.put);
//         if (methods.includes("PATCH")) this.router.patch(`${normalizedPath}/:id`, apiController.patch);
//         if (methods.includes("DELETE")) this.router.delete(`${normalizedPath}/:id`, apiController.delete);
//     }

//     // async registerRoute(path, methods) {
//     //     const validMethods = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'];
//     //     if (!path || typeof path !== 'string' || path.includes(' ')) {
//     //         throw new Error('Invalid path');
//     //     }
//     //     if (!methods || !Array.isArray(methods) || methods.length === 0 || !methods.every(m => validMethods.includes(m))) {
//     //         throw new Error('Invalid or empty methods');
//     //     }

//     //     const normalizedPath = path.startsWith('/') ? path : `/${path}`;
//     //     if (this.routes.has(normalizedPath)) {
//     //         throw new Error(`Route ${normalizedPath} already exists`);
//     //     }

//     //     this.routes.set(normalizedPath, methods);
//     //     this._register(normalizedPath, methods);
//     //     await this.saveRoutesToDB(normalizedPath, methods);

//     //     return { message: `Routes for ${normalizedPath} registered`, path: normalizedPath, methods };
//     // }

//     async registerRoute(path, methods, serviceType = null) {
//         const normalizedPath = path.startsWith('/') ? path : `/${path}`;
//         if (this.routes.has(normalizedPath)) throw new Error(`Route ${normalizedPath} already exists`);
//         this.routes.set(normalizedPath, methods);
//         this._register(normalizedPath, methods, serviceType); // âœ… pass serviceType
//         await this.saveRoutesToDB(normalizedPath, methods);
//         return { message: `Registered ${normalizedPath}`, path: normalizedPath, methods };
//     }


//     async getRoutes() {
//         try {
//             const routes = await Route.find();
//             return routes.map(({ path, methods }) => ({ path, methods }));
//         } catch (error) {
//             console.error('Error fetching routes from DB:', error.message);
//             return [];
//         }
//     }

//     getRouter() {
//         return this.router;
//     }
// }

// export default new RouteService();









// server/services/routeService.js
import express from "express";
import mongoose from "mongoose";
import * as apiController from "../controllers/apiController.js";
import Route from "../models/apiModel/apiModel.js";
import { generateQRCode } from "../controllers/services/qrController.js";

class RouteService {
    constructor() {
        this.routes = new Map();
        this.router = express.Router();
        this.loadRoutesFromDB();
    }

    async loadRoutesFromDB() {
        try {
            const savedRoutes = await Route.find();
            savedRoutes.forEach(
                ({ path, methods, serviceType, inputSchema, outputSpec }) => {
                    this.routes.set(path, { methods, serviceType, inputSchema, outputSpec });
                    this._register(path, methods, serviceType, inputSchema, outputSpec);
                }
            );
            console.log("âœ… Routes loaded from MongoDB:", savedRoutes);
        } catch (error) {
            console.error("âŒ Error loading routes from DB:", error.message);
        }
    }

    async saveRoutesToDB(
        normalizedPath,
        methods,
        serviceType = null,
        inputSchema = [],
        outputSpec = {}
    ) {
        try {
            await Route.create({
                path: normalizedPath,
                methods,
                serviceType,
                inputSchema,
                outputSpec,
            });
            console.log(`âœ… Route ${normalizedPath} saved to MongoDB`);
        } catch (error) {
            console.error("âŒ Error saving route to DB:", error.message);
            throw new Error("Failed to save route to database");
        }
    }

    _register(normalizedPath, methods, serviceType = null, inputSchema = [], outputSpec = {}) {
        const handlerWrapper = (serviceHandler) => async (req, res) => {
            // simple schema validation
            if (Array.isArray(inputSchema) && inputSchema.length > 0) {
                const errors = [];
                for (const field of inputSchema) {
                    const val = req.body[field.name];
                    if (field.required && (val === undefined || val === null || val === "")) {
                        errors.push(`${field.name} is required`);
                    }
                }
                if (errors.length) {
                    return res.status(400).json({
                        success: false,
                        message: "Validation failed",
                        errors,
                    });
                }
            }

            try {
                return await serviceHandler(req, res);
            } catch (err) {
                console.error(`ðŸ’¥ Service handler error for ${normalizedPath}:`, err);
                return res
                    .status(500)
                    .json({ success: false, message: "Service execution error", error: err.message });
            }
        };

        const serviceMap = {
            "qr-generator": generateQRCode,
            // add future services here, e.g. "chatgpt": chatgptHandler
        };

        // attach routes dynamically
        if (methods.includes("POST")) {
            if (serviceType && serviceMap[serviceType]) {
                this.router.post(normalizedPath, handlerWrapper(serviceMap[serviceType]));
            } else {
                this.router.post(normalizedPath, handlerWrapper(apiController.post));
            }
        }
        if (methods.includes("GET")) {
            this.router.get(normalizedPath, handlerWrapper(apiController.get));
        }
        if (methods.includes("PUT")) {
            this.router.put(`${normalizedPath}/:id`, handlerWrapper(apiController.put));
        }
        if (methods.includes("PATCH")) {
            this.router.patch(`${normalizedPath}/:id`, handlerWrapper(apiController.patch));
        }
        if (methods.includes("DELETE")) {
            this.router.delete(`${normalizedPath}/:id`, handlerWrapper(apiController.delete));
        }
    }

    async registerRoute(
        path,
        methods,
        serviceType = null,
        inputSchema = [],
        outputSpec = {}
    ) {
        const normalizedPath = path.startsWith("/") ? path : `/${path}`;
        if (this.routes.has(normalizedPath)) throw new Error(`Route ${normalizedPath} already exists`);

        this.routes.set(normalizedPath, { methods, serviceType, inputSchema, outputSpec });
        this._register(normalizedPath, methods, serviceType, inputSchema, outputSpec);

        await this.saveRoutesToDB(normalizedPath, methods, serviceType, inputSchema, outputSpec);
        return {
            message: `âœ… Registered ${normalizedPath}`,
            path: normalizedPath,
            methods,
            serviceType,
            inputSchema,
            outputSpec,
        };
    }

    async getRoutes() {
        try {
            const routes = await Route.find();
            return routes.map(({ path, methods, serviceType }) => ({
                path,
                methods,
                serviceType,
            }));
        } catch (error) {
            console.error("âŒ Error fetching routes:", error.message);
            return [];
        }
    }

    getRouter() {
        return this.router;
    }
}

export default new RouteService();

================================================================================
FILE: vercel.json
================================================================================

{
  "version": 2,
  "builds": [
    {
      "src": "client/package.json",
      "use": "@vercel/static-build"
    },
    {
      "src": "api/index.js",
      "use": "@vercel/node"
    }
  ],
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "api/index.js"
    },
    {
      "src": "/(.*)",
      "dest": "client/dist/$1"
    }
  ]
}

================================================================================
END OF REPOSITORY CONTENTS
================================================================================
